{"ast":null,"code":"import { last, flat_map } from './list.js';\nimport { range } from './index.js';\nimport { memo } from './memo.js';\nimport { by_charcode } from './transform.js';\nfunction Type(type, value) {\n  return {\n    type,\n    value\n  };\n}\nfunction get_tokens(input) {\n  let expr = String(input);\n  let tokens = [],\n    stack = [];\n  if (!expr.startsWith('[') || !expr.endsWith(']')) {\n    return tokens;\n  }\n  for (let i = 1; i < expr.length - 1; ++i) {\n    let c = expr[i];\n    if (c == '-' && expr[i - 1] == '-') {\n      continue;\n    }\n    if (c == '-') {\n      stack.push(c);\n      continue;\n    }\n    if (last(stack) == '-') {\n      stack.pop();\n      let from = stack.pop();\n      tokens.push(from ? Type('range', [from, c]) : Type('char', c));\n      continue;\n    }\n    if (stack.length) {\n      tokens.push(Type('char', stack.pop()));\n    }\n    stack.push(c);\n  }\n  if (stack.length) {\n    tokens.push(Type('char', stack.pop()));\n  }\n  return tokens;\n}\nconst build_range = memo('build_range', input => {\n  let tokens = get_tokens(input);\n  return flat_map(tokens, _ref => {\n    let {\n      type,\n      value\n    } = _ref;\n    if (type == 'char') return value;\n    let [from, to] = value;\n    let reverse = false;\n    if (from > to) {\n      [from, to] = [to, from];\n      reverse = true;\n    }\n    let result = by_charcode(range)(from, to);\n    if (reverse) result.reverse();\n    return result;\n  });\n});\nfunction expand(fn) {\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return fn(...flat_map(args, n => String(n).startsWith('[') ? build_range(n) : n));\n  };\n}\nexport { expand };","map":{"version":3,"names":["last","flat_map","range","memo","by_charcode","Type","type","value","get_tokens","input","expr","String","tokens","stack","startsWith","endsWith","i","length","c","push","pop","from","build_range","to","reverse","result","expand","fn","args","n"],"sources":["/Users/mariaeduardatc/Documents/GitHub/website/node_modules/css-doodle/src/utils/expand.js"],"sourcesContent":["import { last, flat_map } from './list.js';\n\nimport { range } from './index.js';\nimport { memo } from './memo.js';\nimport { by_charcode } from './transform.js';\n\nfunction Type(type, value) {\n  return { type, value };\n}\n\nfunction get_tokens(input) {\n  let expr = String(input);\n  let tokens = [], stack = [];\n  if (!expr.startsWith('[') || !expr.endsWith(']')) {\n    return tokens;\n  }\n\n  for (let i = 1; i < expr.length - 1; ++i) {\n    let c = expr[i];\n    if (c == '-' && expr[i - 1] == '-') {\n      continue;\n    }\n    if (c == '-') {\n      stack.push(c);\n      continue;\n    }\n    if (last(stack) == '-') {\n      stack.pop();\n      let from = stack.pop();\n      tokens.push(from\n        ? Type('range', [ from, c ])\n        : Type('char', c)\n      );\n      continue;\n    }\n    if (stack.length) {\n      tokens.push(Type('char', stack.pop()));\n    }\n    stack.push(c);\n  }\n  if (stack.length) {\n    tokens.push(Type('char', stack.pop()));\n  }\n  return tokens;\n}\n\nconst build_range = memo('build_range', (input) => {\n  let tokens = get_tokens(input);\n  return flat_map(tokens, ({ type, value }) => {\n    if (type == 'char') return value;\n    let [ from, to ] = value;\n    let reverse = false;\n    if (from > to) {\n      [from, to] = [ to, from ];\n      reverse = true;\n    }\n    let result = by_charcode(range)(from, to);\n    if (reverse) result.reverse();\n    return result;\n  });\n});\n\nfunction expand(fn) {\n  return (...args) => fn(...flat_map(args, n =>\n    String(n).startsWith('[') ? build_range(n) : n\n  ));\n}\n\nexport {\n  expand,\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}