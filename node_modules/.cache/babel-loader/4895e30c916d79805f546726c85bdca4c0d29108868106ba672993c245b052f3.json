{"ast":null,"code":"import parse_css from './parser/parse-css.js';\nimport parse_grid from './parser/parse-grid.js';\nimport parse_shaders from './parser/parse-shaders.js';\nimport { generate_css } from './generator/css.js';\nimport { draw_shader } from './generator/shader.js';\nimport { draw_pattern } from './generator/pattern.js';\nimport { draw_canvas } from './generator/canvas.js';\nimport { svg_to_png } from './generator/svg-to-png.js';\nimport * as Uniforms from './uniforms.js';\nimport { get_props } from './utils/get-props.js';\nimport { get_variable, get_all_variables } from './utils/variables.js';\nimport { get_rgba_color } from './utils/get-rgba-color.js';\nimport { get_grid } from './utils/index.js';\nimport Cache from './utils/cache.js';\nimport create_animation_frame from './utils/create-animation-frame.js';\nimport { make_tag_function, cell_id, is_nil, normalize_png_name, cache_image, is_safari, entity, un_entity, maybe } from './utils/index.js';\nif (typeof customElements !== 'undefined') {\n  class Doodle extends HTMLElement {\n    constructor() {\n      super();\n      this.doodle = this.attachShadow({\n        mode: 'open'\n      });\n      this.animations = [];\n      this.extra = {\n        get_variable: name => get_variable(this, name),\n        get_rgba_color: value => get_rgba_color(this.shadowRoot, value)\n      };\n    }\n    connectedCallback(again) {\n      if (this.innerHTML) {\n        this.load(again);\n      } else {\n        setTimeout(() => this.load(again));\n      }\n    }\n    disconnectedCallback() {\n      this.cleanup();\n    }\n    cleanup() {\n      Cache.clear();\n      for (let animation of this.animations) {\n        animation.cancel();\n      }\n      this.animations = [];\n    }\n    update(styles) {\n      this.cleanup();\n      // Use old rules to update\n      if (!styles) {\n        styles = un_entity(this._innerHTML);\n      }\n      if (this._innerHTML !== styles) {\n        this._innerHTML = styles;\n      }\n      if (!this.grid_size) {\n        this.grid_size = this.get_grid();\n      }\n      const {\n        x: gx,\n        y: gy,\n        z: gz\n      } = this.grid_size;\n      const use = this.get_use();\n      let old_content = '';\n      if (this.compiled) {\n        old_content = this.compiled.content;\n      }\n      const compiled = this.generate(parse_css(use + styles, this.extra));\n      let grid = compiled.grid || this.get_grid();\n      let {\n        x,\n        y,\n        z\n      } = grid;\n      let should_rebuild = !this.shadowRoot.innerHTML || this.shadowRoot.querySelector('css-doodle') || gx !== x || gy !== y || gz !== z || JSON.stringify(old_content) !== JSON.stringify(compiled.content);\n      Object.assign(this.grid_size, grid);\n      if (should_rebuild) {\n        return compiled.grid ? this.build_grid(compiled, grid) : this.build_grid(this.generate(parse_css(use + styles, this.extra)), grid);\n      }\n      let replace = this.replace(compiled);\n      this.set_content('.style-keyframes', replace(compiled.styles.keyframes));\n      if (compiled.props.has_animation) {\n        this.set_content('.style-cells', '');\n        this.set_content('.style-container', '');\n      }\n      setTimeout(() => {\n        this.set_content('.style-container', replace(get_grid_styles(this.grid_size) + compiled.styles.host + compiled.styles.container));\n        this.set_content('.style-cells', replace(compiled.styles.cells));\n      });\n    }\n    get grid() {\n      return Object.assign({}, this.grid_size);\n    }\n    set grid(grid) {\n      this.attr('grid', grid);\n      this.connectedCallback(true);\n    }\n    get seed() {\n      return this._seed_value;\n    }\n    set seed(seed) {\n      this.attr('seed', seed);\n      this.connectedCallback(true);\n    }\n    get use() {\n      return this.attr('use');\n    }\n    set use(use) {\n      this.attr('use', use);\n      this.connectedCallback(true);\n    }\n    get_max_grid() {\n      return this.hasAttribute('experimental') ? 256 : 64;\n    }\n    get_grid() {\n      return parse_grid(this.attr('grid'), this.get_max_grid());\n    }\n    get_use() {\n      let use = String(this.attr('use') || '').trim();\n      if (/^var\\(/.test(use)) {\n        use = `@use:${use};`;\n      }\n      return use;\n    }\n    attr(name, value) {\n      if (arguments.length === 1) {\n        return this.getAttribute(name);\n      }\n      if (arguments.length === 2) {\n        this.setAttribute(name, value);\n        return value;\n      }\n    }\n    generate(parsed) {\n      let grid = this.get_grid();\n      let seed = this.attr('seed') || this.attr('data-seed');\n      if (is_nil(seed)) {\n        seed = Date.now();\n      }\n      let compiled = this.compiled = generate_css(parsed, grid, seed, this.get_max_grid());\n      this._seed_value = compiled.seed;\n      this._seed_random = compiled.random;\n      return compiled;\n    }\n    doodle_to_image(code, options, fn) {\n      if (typeof options === 'function') {\n        fn = options;\n        options = null;\n      }\n      code = ':doodle { width:100%;height:100% }' + code;\n      let parsed = parse_css(code, this.extra);\n      let _grid = parse_grid('');\n      let compiled = generate_css(parsed, _grid, this._seed_value, this.get_max_grid(), this._seed_random);\n      let grid = compiled.grid ? compiled.grid : _grid;\n      const {\n        keyframes,\n        host,\n        container,\n        cells\n      } = compiled.styles;\n      let viewBox = '';\n      if (options && options.arg) {\n        let v = get_grid(options.arg);\n        if (v.x && v.y) {\n          options.width = v.x + 'px';\n          options.height = v.y + 'px';\n          viewBox = `viewBox=\"0 0 ${v.x} ${v.y}\"`;\n        }\n      }\n      let replace = this.replace(compiled);\n      let grid_container = create_grid(grid, compiled.content);\n      let size = options && options.width && options.height ? `width=\"${options.width}\" height=\"${options.height}\"` : '';\n      replace(`\n        <svg ${size} xmlns=\"http://www.w3.org/2000/svg\" preserveAspectRatio=\"none\" ${viewBox}>\n          <foreignObject width=\"100%\" height=\"100%\">\n            <div class=\"host\" width=\"100%\" height=\"100%\" xmlns=\"http://www.w3.org/1999/xhtml\">\n              <style>\n                ${get_basic_styles()}\n                ${get_grid_styles(grid)}\n                ${host}\n                ${container}\n                ${cells}\n                ${keyframes}\n              </style>\n              <svg id=\"defs\" xmlns=\"http://www.w3.org/2000/svg\" style=\"width:0; height:0\"></svg>\n              ${grid_container}\n            </div>\n          </foreignObject>\n        </svg>\n      `).then(result => {\n        let source = `data:image/svg+xml;base64,${window.btoa(unescape(encodeURIComponent(result)))}`;\n        if (is_safari()) {\n          cache_image(source);\n        }\n        fn(source);\n      });\n    }\n    pattern_to_image(_ref, fn) {\n      let {\n        code,\n        cell,\n        id\n      } = _ref;\n      let shader = draw_pattern(code, this.extra);\n      this.shader_to_image({\n        shader,\n        cell,\n        id\n      }, fn);\n    }\n    canvas_to_image(_ref2, fn) {\n      let {\n        code\n      } = _ref2;\n      draw_canvas(code).then(fn);\n    }\n    pause() {\n      this.setAttribute('cssd-paused-animation', true);\n      for (let animation of this.animations) {\n        animation.pause();\n      }\n    }\n    resume() {\n      this.removeAttribute('cssd-paused-animation');\n      for (let animation of this.animations) {\n        animation.resume();\n      }\n    }\n    shader_to_image(_ref3, fn) {\n      let {\n        shader,\n        cell,\n        id\n      } = _ref3;\n      let parsed = typeof shader === 'string' ? parse_shaders(shader) : shader;\n      let element = this.doodle.getElementById(cell);\n      const seed = this.seed;\n      const set_shader_prop = v => {\n        element.style.setProperty(id, `url(${v})`);\n      };\n      const tick = value => {\n        if (typeof value === 'function') {\n          let animation = create_animation_frame(t => {\n            set_shader_prop(value(t));\n          });\n          this.animations.push(animation);\n          return '';\n        }\n        set_shader_prop(value);\n      };\n      let {\n        width,\n        height\n      } = element && element.getBoundingClientRect() || {\n        width: 0,\n        height: 0\n      };\n      let ratio = window.devicePixelRatio || 1;\n      if (!parsed.textures.length || parsed.ticker) {\n        draw_shader(parsed, width, height, seed).then(tick).then(fn);\n      }\n      // Need to bind textures first\n      else {\n        let transforms = parsed.textures.map(texture => {\n          return new Promise(resolve => {\n            this.doodle_to_image(texture.value, {\n              width,\n              height\n            }, src => {\n              let img = new Image();\n              img.width = width * ratio;\n              img.height = height * ratio;\n              img.onload = () => resolve({\n                name: texture.name,\n                value: img\n              });\n              img.src = src;\n            });\n          });\n        });\n        Promise.all(transforms).then(textures => {\n          parsed.textures = textures;\n          draw_shader(parsed, width, height, seed).then(tick).then(fn);\n        });\n      }\n    }\n    load(again) {\n      this.cleanup();\n      let use = this.get_use();\n      let parsed = parse_css(use + un_entity(this.innerHTML), this.extra);\n      let compiled = this.generate(parsed);\n      if (!again) {\n        if (this.hasAttribute('click-to-update')) {\n          this.addEventListener('click', e => this.update());\n        }\n      }\n      this.grid_size = compiled.grid ? compiled.grid : this.get_grid();\n      this.build_grid(compiled, this.grid_size);\n      this._innerHTML = this.innerHTML;\n      this.innerHTML = '';\n    }\n    replace(_ref4) {\n      let {\n        doodles,\n        shaders,\n        canvas,\n        pattern\n      } = _ref4;\n      let doodle_ids = Object.keys(doodles);\n      let shader_ids = Object.keys(shaders);\n      let canvas_ids = Object.keys(canvas);\n      let pattern_ids = Object.keys(pattern);\n      let length = doodle_ids.length + canvas_ids.length + shader_ids.length + pattern_ids.length;\n      return input => {\n        if (!length) {\n          return Promise.resolve(input);\n        }\n        let mappings = [].concat(doodle_ids.map(id => {\n          if (input.includes(id)) {\n            return new Promise(resolve => {\n              let {\n                arg,\n                doodle\n              } = doodles[id];\n              this.doodle_to_image(doodle, {\n                arg\n              }, value => resolve({\n                id,\n                value\n              }));\n            });\n          } else {\n            return Promise.resolve('');\n          }\n        }), shader_ids.map(id => {\n          if (input.includes(id)) {\n            return new Promise(resolve => {\n              this.shader_to_image(shaders[id], value => resolve({\n                id,\n                value\n              }));\n            });\n          } else {\n            return Promise.resolve('');\n          }\n        }), canvas_ids.map(id => {\n          if (input.includes(id)) {\n            return new Promise(resolve => {\n              this.canvas_to_image(canvas[id], value => resolve({\n                id,\n                value\n              }));\n            });\n          } else {\n            return Promise.resolve('');\n          }\n        }), pattern_ids.map(id => {\n          if (input.includes(id)) {\n            return new Promise(resolve => {\n              this.pattern_to_image(pattern[id], value => resolve({\n                id,\n                value\n              }));\n            });\n          } else {\n            return Promise.resolve('');\n          }\n        }));\n        return Promise.all(mappings).then(mapping => {\n          for (let {\n            id,\n            value\n          } of mapping) {\n            /* default to data-uri for doodle and pattern */\n            let target = `url(${value})`;\n            /* canvas uses css painting api */\n            if (/^canvas/.test(id)) target = value;\n            /* shader uses css vars */\n            if (/^shader|^pattern/.test(id)) target = `var(--${id})`;\n            input = input.replaceAll('${' + id + '}', target);\n          }\n          return input;\n        });\n      };\n    }\n    build_grid(compiled, grid) {\n      const {\n        has_transition,\n        has_animation\n      } = compiled.props;\n      let has_delay = has_transition || has_animation;\n      const {\n        keyframes,\n        host,\n        container,\n        cells\n      } = compiled.styles;\n      let style_container = get_grid_styles(grid) + host + container;\n      let style_cells = has_delay ? '' : cells;\n      const {\n        uniforms,\n        content\n      } = compiled;\n      let replace = this.replace(compiled);\n      this.doodle.innerHTML = `\n        <style>${get_basic_styles()}</style>\n        <style class=\"style-keyframes\">${keyframes}</style>\n        <style class=\"style-container\">${style_container}</style>\n        <style class=\"style-cells\">${style_cells}</style>\n        <svg id=\"defs\" xmlns=\"http://www.w3.org/2000/svg\" style=\"width:0;height:0\"></svg>\n        ${create_grid(grid, content)}\n      `;\n      this.set_content('.style-container', replace(style_container));\n      if (has_delay) {\n        setTimeout(() => {\n          this.set_content('.style-cells', replace(cells));\n        }, 50);\n      } else {\n        this.set_content('.style-cells', replace(cells));\n      }\n      if (uniforms.time) {\n        this.register_uniform_time();\n      }\n      if (uniforms.mousex || uniforms.mousey) {\n        this.register_uniform_mouse(uniforms);\n      } else {\n        this.remove_uniform_mouse();\n      }\n      if (uniforms.width || uniforms.height) {\n        this.register_uniform_resolution(uniforms);\n      } else {\n        this.remove_uniform_resolution();\n      }\n    }\n    register_uniform_mouse(uniforms) {\n      if (!this.uniform_mouse_callback) {\n        let {\n          uniform_mousex,\n          uniform_mousey\n        } = Uniforms;\n        this.uniform_mouse_callback = e => {\n          let data = e.detail || e;\n          if (uniforms.mousex) {\n            this.style.setProperty('--' + uniform_mousex.name, data.offsetX);\n          }\n          if (uniforms.mousey) {\n            this.style.setProperty('--' + uniform_mousey.name, data.offsetY);\n          }\n        };\n        this.addEventListener('pointermove', this.uniform_mouse_callback);\n        let event = new CustomEvent('pointermove', {\n          detail: {\n            offsetX: 0,\n            offsetY: 0\n          }\n        });\n        this.dispatchEvent(event);\n      }\n    }\n    remove_uniform_mouse() {\n      if (this.uniform_mouse_callback) {\n        let {\n          uniform_mousex,\n          uniform_mousey\n        } = Uniforms;\n        this.style.removeProperty('--' + uniform_mousex.name);\n        this.style.removeProperty('--' + uniform_mousey.name);\n        this.removeEventListener('pointermove', this.uniform_mouse_callback);\n        this.uniform_mouse_callback = null;\n      }\n    }\n    register_uniform_resolution(uniforms) {\n      if (!this.uniform_resolution_observer) {\n        let {\n          uniform_width,\n          uniform_height\n        } = Uniforms;\n        const setProperty = () => {\n          let box = this.getBoundingClientRect();\n          if (uniforms.width) {\n            this.style.setProperty('--' + uniform_width.name, box.width);\n          }\n          if (uniforms.height) {\n            this.style.setProperty('--' + uniform_height.name, box.height);\n          }\n        };\n        setProperty();\n        this.uniform_resolution_observer = new ResizeObserver(entries => {\n          for (let entry of entries) {\n            let data = entry.contentBoxSize || entry.contentRect;\n            if (data) setProperty();\n          }\n        });\n        this.uniform_resolution_observer.observe(this);\n      }\n    }\n    remove_uniform_resolution() {\n      if (this.uniform_resolution_observer) {\n        let {\n          uniform_width,\n          uniform_height\n        } = Uniforms;\n        this.style.removeProperty('--' + uniform_width.name);\n        this.style.removeProperty('--' + uniform_height.name);\n        this.uniform_resolution_observer.unobserve(this);\n        this.uniform_resolution_observer = null;\n      }\n    }\n    register_uniform_time() {\n      if (!window.CSS || !window.CSS.registerProperty) {\n        return false;\n      }\n      if (!this.is_uniform_time_registered) {\n        let {\n          uniform_time\n        } = Uniforms;\n        try {\n          CSS.registerProperty({\n            name: '--' + uniform_time.name,\n            syntax: '<number>',\n            initialValue: 0,\n            inherits: true\n          });\n        } catch (e) {}\n        this.is_uniform_time_registered = true;\n      }\n    }\n    export() {\n      let {\n        scale,\n        name,\n        download,\n        detail\n      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return new Promise((resolve, reject) => {\n        let variables = get_all_variables(this);\n        let html = this.doodle.innerHTML;\n        let {\n          width,\n          height\n        } = this.getBoundingClientRect();\n        scale = parseInt(scale) || 1;\n        let w = width * scale;\n        let h = height * scale;\n        let svg = `\n          <svg xmlns=\"http://www.w3.org/2000/svg\"\n            preserveAspectRatio=\"none\"\n            viewBox=\"0 0 ${width} ${height}\"\n            ${is_safari() ? '' : `width=\"${w}px\" height=\"${h}px\"`}\n          >\n            <foreignObject width=\"100%\" height=\"100%\">\n              <div\n                class=\"host\"\n                xmlns=\"http://www.w3.org/1999/xhtml\"\n                style=\"width: ${width}px; height: ${height}px; \"\n              >\n                <style>.host { ${entity(variables)} }</style>\n                ${html}\n              </div>\n            </foreignObject>\n          </svg>\n        `;\n        if (download || detail) {\n          svg_to_png(svg, w, h, scale).then(_ref5 => {\n            let {\n              source,\n              url,\n              blob\n            } = _ref5;\n            resolve({\n              width: w,\n              height: h,\n              svg,\n              blob,\n              source\n            });\n            if (download) {\n              let a = document.createElement('a');\n              a.download = normalize_png_name(name);\n              a.href = url;\n              a.click();\n            }\n          }).catch(error => {\n            reject(error);\n          });\n        } else {\n          resolve({\n            width: w,\n            height: h,\n            svg: svg\n          });\n        }\n      });\n    }\n    set_content(selector, styles) {\n      if (styles instanceof Promise) {\n        styles.then(value => {\n          this.set_content(selector, value);\n        });\n      } else {\n        const el = this.shadowRoot.querySelector(selector);\n        el && (el.styleSheet ? el.styleSheet.cssText = styles : el.innerHTML = styles);\n      }\n    }\n  }\n  if (!customElements.get('css-doodle')) {\n    customElements.define('css-doodle', Doodle);\n  }\n}\nfunction get_basic_styles() {\n  let {\n    uniform_time\n  } = Uniforms;\n  const inherited_grid_props = get_props(/grid/).map(n => `${n}: inherit;`).join('');\n  return `\n    *, *::after, *::before {\n      box-sizing: border-box;\n    }\n    :host, .host {\n      display: block;\n      visibility: visible;\n      width: auto;\n      height: auto;\n      contain: content;\n      box-sizing: border-box;\n      --${uniform_time.name}: 0\n    }\n    :host([hidden]), .host[hidden] {\n      display: none\n    }\n    .container {\n      position: relative;\n      width: 100%;\n      height: 100%;\n      display: grid;\n      ${inherited_grid_props}\n    }\n    cell {\n      position: relative;\n      display: grid;\n      place-items: center\n    }\n    svg {\n      position: absolute;\n      width: 100%;\n      height: 100%\n    }\n    :host([cssd-paused-animation]),\n    :host([cssd-paused-animation]) * {\n      animation-play-state: paused !important\n    }\n  `;\n}\nfunction get_grid_styles(grid_obj) {\n  let {\n    x,\n    y\n  } = grid_obj || {};\n  return `\n    :host, .host {\n      grid-template-rows: repeat(${y}, 1fr);\n      grid-template-columns: repeat(${x}, 1fr);\n    }\n  `;\n}\nfunction get_content(input) {\n  return is_nil(input) ? '' : input;\n}\nfunction create_cell(x, y, z, content) {\n  let child = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '';\n  let id = cell_id(x, y, z);\n  let head = get_content(content['#' + id]);\n  let tail = get_content(child);\n  return `<cell id=\"${id}\">${head}${tail}</cell>`;\n}\nfunction create_grid(grid_obj, content) {\n  let {\n    x,\n    y,\n    z\n  } = grid_obj || {};\n  let result = '';\n  if (z == 1) {\n    for (let j = 1; j <= y; ++j) {\n      for (let i = 1; i <= x; ++i) {\n        result += create_cell(i, j, 1, content);\n      }\n    }\n  } else {\n    let child = '';\n    for (let i = z; i >= 1; i--) {\n      let cell = create_cell(1, 1, i, content, child);\n      child = cell;\n    }\n    result = child;\n  }\n  return `<grid class=\"container\">${result}</grid>`;\n}\nexport default make_tag_function(rules => {\n  if (typeof document !== 'undefined') {\n    let doodle = document.createElement('css-doodle');\n    if (doodle.update) {\n      doodle.update(rules);\n    }\n    return doodle;\n  }\n});","map":{"version":3,"names":["parse_css","parse_grid","parse_shaders","generate_css","draw_shader","draw_pattern","draw_canvas","svg_to_png","Uniforms","get_props","get_variable","get_all_variables","get_rgba_color","get_grid","Cache","create_animation_frame","make_tag_function","cell_id","is_nil","normalize_png_name","cache_image","is_safari","entity","un_entity","maybe","customElements","Doodle","HTMLElement","constructor","doodle","attachShadow","mode","animations","extra","name","value","shadowRoot","connectedCallback","again","innerHTML","load","setTimeout","disconnectedCallback","cleanup","clear","animation","cancel","update","styles","_innerHTML","grid_size","x","gx","y","gy","z","gz","use","get_use","old_content","compiled","content","generate","grid","should_rebuild","querySelector","JSON","stringify","Object","assign","build_grid","replace","set_content","keyframes","props","has_animation","get_grid_styles","host","container","cells","attr","seed","_seed_value","get_max_grid","hasAttribute","String","trim","test","arguments","length","getAttribute","setAttribute","parsed","Date","now","_seed_random","random","doodle_to_image","code","options","fn","_grid","viewBox","arg","v","width","height","grid_container","create_grid","size","get_basic_styles","then","result","source","window","btoa","unescape","encodeURIComponent","pattern_to_image","cell","id","shader","shader_to_image","canvas_to_image","pause","resume","removeAttribute","element","getElementById","set_shader_prop","style","setProperty","tick","t","push","getBoundingClientRect","ratio","devicePixelRatio","textures","ticker","transforms","map","texture","Promise","resolve","src","img","Image","onload","all","addEventListener","e","doodles","shaders","canvas","pattern","doodle_ids","keys","shader_ids","canvas_ids","pattern_ids","input","mappings","concat","includes","mapping","target","replaceAll","has_transition","has_delay","style_container","style_cells","uniforms","time","register_uniform_time","mousex","mousey","register_uniform_mouse","remove_uniform_mouse","register_uniform_resolution","remove_uniform_resolution","uniform_mouse_callback","uniform_mousex","uniform_mousey","data","detail","offsetX","offsetY","event","CustomEvent","dispatchEvent","removeProperty","removeEventListener","uniform_resolution_observer","uniform_width","uniform_height","box","ResizeObserver","entries","entry","contentBoxSize","contentRect","observe","unobserve","CSS","registerProperty","is_uniform_time_registered","uniform_time","syntax","initialValue","inherits","export","scale","download","reject","variables","html","parseInt","w","h","svg","url","blob","a","document","createElement","href","click","catch","error","selector","el","styleSheet","cssText","get","define","inherited_grid_props","n","join","grid_obj","get_content","create_cell","child","head","tail","j","i","rules"],"sources":["/Users/mariaeduardatc/Documents/GitHub/website/node_modules/css-doodle/src/index.js"],"sourcesContent":["import parse_css from './parser/parse-css.js';\nimport parse_grid from './parser/parse-grid.js';\nimport parse_shaders from './parser/parse-shaders.js';\n\nimport { generate_css } from './generator/css.js';\nimport { draw_shader } from './generator/shader.js';\nimport { draw_pattern } from './generator/pattern.js';\nimport { draw_canvas } from './generator/canvas.js';\nimport { svg_to_png } from './generator/svg-to-png.js';\n\nimport * as Uniforms from './uniforms.js';\n\nimport { get_props } from './utils/get-props.js';\nimport { get_variable, get_all_variables } from './utils/variables.js';\nimport { get_rgba_color } from './utils/get-rgba-color.js';\nimport { get_grid } from './utils/index.js';\nimport Cache from './utils/cache.js';\nimport create_animation_frame from './utils/create-animation-frame.js';\n\nimport {\n  make_tag_function,\n  cell_id, is_nil,\n  normalize_png_name, cache_image,\n  is_safari, entity, un_entity,\n  maybe\n} from './utils/index.js';\n\nif (typeof customElements !== 'undefined') {\n  class Doodle extends HTMLElement {\n    constructor() {\n      super();\n      this.doodle = this.attachShadow({ mode: 'open' });\n      this.animations = [];\n      this.extra = {\n        get_variable: name => get_variable(this, name),\n        get_rgba_color: value => get_rgba_color(this.shadowRoot, value),\n      };\n    }\n\n    connectedCallback(again) {\n      if (this.innerHTML) {\n        this.load(again);\n      } else {\n        setTimeout(() => this.load(again));\n      }\n    }\n\n    disconnectedCallback() {\n      this.cleanup();\n    }\n\n    cleanup() {\n      Cache.clear();\n      for (let animation of this.animations) {\n        animation.cancel();\n      }\n      this.animations = [];\n    }\n\n    update(styles) {\n      this.cleanup();\n      // Use old rules to update\n      if (!styles) {\n        styles = un_entity(this._innerHTML);\n      }\n      if (this._innerHTML !== styles) {\n        this._innerHTML = styles;\n      }\n      if (!this.grid_size) {\n        this.grid_size = this.get_grid();\n      }\n\n      const { x: gx, y: gy, z: gz } = this.grid_size;\n      const use = this.get_use();\n\n      let old_content = '';\n      if (this.compiled) {\n        old_content = this.compiled.content;\n      }\n\n      const compiled = this.generate(parse_css(use + styles, this.extra));\n\n      let grid = compiled.grid || this.get_grid();\n      let { x, y, z } = grid;\n\n      let should_rebuild = (\n           !this.shadowRoot.innerHTML\n        ||  this.shadowRoot.querySelector('css-doodle')\n        || (gx !== x || gy !== y || gz !== z)\n        || (JSON.stringify(old_content) !== JSON.stringify(compiled.content))\n      );\n\n      Object.assign(this.grid_size, grid);\n\n      if (should_rebuild) {\n        return compiled.grid\n          ? this.build_grid(compiled, grid)\n          : this.build_grid(this.generate(parse_css(use + styles, this.extra)), grid);\n      }\n\n      let replace = this.replace(compiled);\n      this.set_content('.style-keyframes', replace(compiled.styles.keyframes));\n\n      if (compiled.props.has_animation) {\n        this.set_content('.style-cells', '');\n        this.set_content('.style-container', '');\n      }\n\n      setTimeout(() => {\n        this.set_content('.style-container', replace(\n            get_grid_styles(this.grid_size)\n          + compiled.styles.host\n          + compiled.styles.container\n        ));\n        this.set_content('.style-cells', replace(compiled.styles.cells));\n      });\n    }\n\n    get grid() {\n      return Object.assign({}, this.grid_size);\n    }\n\n    set grid(grid) {\n      this.attr('grid', grid);\n      this.connectedCallback(true);\n    }\n\n    get seed() {\n      return this._seed_value;\n    }\n\n    set seed(seed) {\n      this.attr('seed', seed);\n      this.connectedCallback(true);\n    }\n\n    get use() {\n      return this.attr('use');\n    }\n\n    set use(use) {\n      this.attr('use', use);\n      this.connectedCallback(true);\n    }\n\n    get_max_grid() {\n      return this.hasAttribute('experimental') ? 256 : 64;\n    }\n\n    get_grid() {\n      return parse_grid(this.attr('grid'), this.get_max_grid());\n    }\n\n    get_use() {\n      let use = String(this.attr('use') || '').trim();\n      if (/^var\\(/.test(use)) {\n        use = `@use:${ use };`;\n      }\n      return use;\n    }\n\n    attr(name, value) {\n      if (arguments.length === 1) {\n        return this.getAttribute(name);\n      }\n      if (arguments.length === 2) {\n        this.setAttribute(name, value);\n        return value;\n      }\n    }\n\n    generate(parsed) {\n      let grid = this.get_grid();\n      let seed = this.attr('seed') || this.attr('data-seed');\n      if (is_nil(seed)) {\n        seed = Date.now();\n      }\n      let compiled = this.compiled = generate_css(\n        parsed, grid, seed, this.get_max_grid()\n      );\n      this._seed_value = compiled.seed;\n      this._seed_random = compiled.random;\n      return compiled;\n    }\n\n    doodle_to_image(code, options, fn) {\n      if (typeof options === 'function') {\n        fn = options;\n        options = null;\n      }\n      code = ':doodle { width:100%;height:100% }' + code;\n      let parsed = parse_css(code, this.extra);\n      let _grid = parse_grid('');\n      let compiled = generate_css(parsed, _grid, this._seed_value, this.get_max_grid(), this._seed_random);\n      let grid = compiled.grid ? compiled.grid : _grid;\n      const { keyframes, host, container, cells } = compiled.styles;\n\n      let viewBox = '';\n      if (options && options.arg) {\n        let v = get_grid(options.arg);\n        if (v.x && v.y) {\n          options.width = v.x + 'px';\n          options.height = v.y + 'px';\n          viewBox = `viewBox=\"0 0 ${v.x} ${v.y}\"`;\n        }\n      }\n\n      let replace = this.replace(compiled);\n      let grid_container = create_grid(grid, compiled.content);\n\n      let size = (options && options.width && options.height)\n        ? `width=\"${ options.width }\" height=\"${ options.height }\"`\n        : '';\n\n      replace(`\n        <svg ${ size } xmlns=\"http://www.w3.org/2000/svg\" preserveAspectRatio=\"none\" ${viewBox}>\n          <foreignObject width=\"100%\" height=\"100%\">\n            <div class=\"host\" width=\"100%\" height=\"100%\" xmlns=\"http://www.w3.org/1999/xhtml\">\n              <style>\n                ${ get_basic_styles() }\n                ${ get_grid_styles(grid) }\n                ${ host }\n                ${ container }\n                ${ cells }\n                ${ keyframes }\n              </style>\n              <svg id=\"defs\" xmlns=\"http://www.w3.org/2000/svg\" style=\"width:0; height:0\"></svg>\n              ${ grid_container }\n            </div>\n          </foreignObject>\n        </svg>\n      `).then(result => {\n        let source =`data:image/svg+xml;base64,${ window.btoa(unescape(encodeURIComponent(result))) }`;\n        if (is_safari()) {\n          cache_image(source);\n        }\n        fn(source);\n      });\n    }\n\n    pattern_to_image({ code, cell, id }, fn) {\n      let shader = draw_pattern(code, this.extra);\n      this.shader_to_image({ shader, cell, id }, fn);\n    }\n\n    canvas_to_image({ code }, fn) {\n      draw_canvas(code).then(fn);\n    }\n\n    pause() {\n      this.setAttribute('cssd-paused-animation', true);\n      for (let animation of this.animations) {\n        animation.pause();\n      }\n    }\n\n    resume() {\n      this.removeAttribute('cssd-paused-animation');\n      for (let animation of this.animations) {\n        animation.resume();\n      }\n    }\n\n    shader_to_image({ shader, cell, id }, fn) {\n      let parsed = typeof shader === 'string' ?  parse_shaders(shader) : shader;\n      let element = this.doodle.getElementById(cell);\n      const seed = this.seed;\n\n      const set_shader_prop = (v) => {\n        element.style.setProperty(id, `url(${v})`);\n      }\n\n      const tick = (value) => {\n        if (typeof value === 'function') {\n          let animation = create_animation_frame(t => {\n            set_shader_prop(value(t));\n          });\n          this.animations.push(animation);\n          return '';\n        }\n        set_shader_prop(value);\n      }\n\n      let { width, height } = element && element.getBoundingClientRect() || {\n        width: 0, height: 0\n      };\n\n      let ratio = window.devicePixelRatio || 1;\n      if (!parsed.textures.length || parsed.ticker) {\n        draw_shader(parsed, width, height, seed).then(tick).then(fn);\n      }\n      // Need to bind textures first\n      else {\n        let transforms = parsed.textures.map(texture => {\n          return new Promise(resolve => {\n            this.doodle_to_image(texture.value, { width, height }, src => {\n              let img = new Image();\n              img.width = width * ratio;\n              img.height = height * ratio;\n              img.onload = () => resolve({ name: texture.name, value: img });\n              img.src = src;\n            });\n          });\n        });\n        Promise.all(transforms).then(textures => {\n          parsed.textures = textures;\n          draw_shader(parsed, width, height, seed).then(tick).then(fn);\n        });\n      }\n    }\n\n    load(again) {\n      this.cleanup();\n      let use = this.get_use();\n      let parsed = parse_css(use + un_entity(this.innerHTML), this.extra);\n      let compiled = this.generate(parsed);\n\n      if (!again) {\n        if (this.hasAttribute('click-to-update')) {\n          this.addEventListener('click', e => this.update());\n        }\n      }\n\n      this.grid_size = compiled.grid\n        ? compiled.grid\n        : this.get_grid();\n\n      this.build_grid(compiled, this.grid_size);\n      this._innerHTML = this.innerHTML;\n      this.innerHTML = '';\n    }\n\n    replace({ doodles, shaders, canvas, pattern }) {\n      let doodle_ids = Object.keys(doodles);\n      let shader_ids = Object.keys(shaders);\n      let canvas_ids = Object.keys(canvas);\n      let pattern_ids = Object.keys(pattern);\n      let length = doodle_ids.length + canvas_ids.length + shader_ids.length + pattern_ids.length;\n      return input => {\n        if (!length) {\n          return Promise.resolve(input);\n        }\n        let mappings = [].concat(\n          doodle_ids.map(id => {\n            if (input.includes(id)) {\n              return new Promise(resolve => {\n                let { arg, doodle } = doodles[id];\n                this.doodle_to_image(doodle, { arg }, value => resolve({ id, value }));\n              });\n            } else {\n              return Promise.resolve('');\n            }\n          }),\n          shader_ids.map(id => {\n            if (input.includes(id)) {\n              return new Promise(resolve => {\n                this.shader_to_image(shaders[id], value => resolve({ id, value }));\n              });\n            } else {\n              return Promise.resolve('');\n            }\n          }),\n          canvas_ids.map(id => {\n            if (input.includes(id)) {\n              return new Promise(resolve => {\n                this.canvas_to_image(canvas[id], value => resolve({ id, value }));\n              });\n            } else {\n              return Promise.resolve('');\n            }\n          }),\n          pattern_ids.map(id => {\n            if (input.includes(id)) {\n              return new Promise(resolve => {\n                this.pattern_to_image(pattern[id], value => resolve({ id, value }));\n              });\n            } else {\n              return Promise.resolve('');\n            }\n          }),\n        );\n\n        return Promise.all(mappings).then(mapping => {\n          for (let {id, value} of mapping) {\n            /* default to data-uri for doodle and pattern */\n            let target = `url(${value})`;\n            /* canvas uses css painting api */\n            if (/^canvas/.test(id)) target = value;\n            /* shader uses css vars */\n            if (/^shader|^pattern/.test(id)) target = `var(--${id})`;\n            input = input.replaceAll('${' + id + '}', target);\n          }\n          return input;\n        });\n      }\n    }\n\n    build_grid(compiled, grid) {\n      const { has_transition, has_animation } = compiled.props;\n      let has_delay = (has_transition || has_animation);\n\n      const { keyframes, host, container, cells } = compiled.styles;\n      let style_container = get_grid_styles(grid) + host + container;\n      let style_cells = has_delay ? '' : cells;\n\n      const { uniforms, content } = compiled;\n\n      let replace = this.replace(compiled);\n\n      this.doodle.innerHTML = `\n        <style>${ get_basic_styles() }</style>\n        <style class=\"style-keyframes\">${ keyframes }</style>\n        <style class=\"style-container\">${ style_container }</style>\n        <style class=\"style-cells\">${ style_cells }</style>\n        <svg id=\"defs\" xmlns=\"http://www.w3.org/2000/svg\" style=\"width:0;height:0\"></svg>\n        ${ create_grid(grid, content) }\n      `;\n\n      this.set_content('.style-container', replace(style_container));\n\n      if (has_delay) {\n        setTimeout(() => {\n          this.set_content('.style-cells', replace(cells));\n        }, 50);\n      } else {\n        this.set_content('.style-cells', replace(cells));\n      }\n\n      if (uniforms.time) {\n        this.register_uniform_time();\n      }\n      if (uniforms.mousex || uniforms.mousey) {\n        this.register_uniform_mouse(uniforms);\n      } else {\n        this.remove_uniform_mouse();\n      }\n      if (uniforms.width || uniforms.height) {\n        this.register_uniform_resolution(uniforms);\n      } else {\n        this.remove_uniform_resolution();\n      }\n    }\n\n    register_uniform_mouse(uniforms) {\n      if (!this.uniform_mouse_callback) {\n        let { uniform_mousex, uniform_mousey } = Uniforms;\n        this.uniform_mouse_callback = e => {\n          let data = e.detail || e;\n          if (uniforms.mousex) {\n            this.style.setProperty('--' + uniform_mousex.name, data.offsetX);\n          }\n          if (uniforms.mousey) {\n            this.style.setProperty('--' + uniform_mousey.name, data.offsetY);\n          }\n        }\n        this.addEventListener('pointermove', this.uniform_mouse_callback);\n        let event = new CustomEvent('pointermove', { detail: { offsetX: 0, offsetY: 0}});\n        this.dispatchEvent(event);\n      }\n    }\n\n    remove_uniform_mouse() {\n      if (this.uniform_mouse_callback) {\n        let { uniform_mousex, uniform_mousey } = Uniforms;\n        this.style.removeProperty('--' + uniform_mousex.name);\n        this.style.removeProperty('--' + uniform_mousey.name);\n        this.removeEventListener('pointermove', this.uniform_mouse_callback);\n        this.uniform_mouse_callback = null;\n      }\n    }\n\n    register_uniform_resolution(uniforms) {\n      if (!this.uniform_resolution_observer) {\n        let { uniform_width, uniform_height } = Uniforms;\n        const setProperty = () => {\n          let box = this.getBoundingClientRect();\n          if (uniforms.width) {\n            this.style.setProperty('--' + uniform_width.name, box.width);\n          }\n          if (uniforms.height) {\n            this.style.setProperty('--' + uniform_height.name, box.height);\n          }\n        };\n        setProperty();\n        this.uniform_resolution_observer = new ResizeObserver(entries => {\n          for (let entry of entries) {\n            let data = entry.contentBoxSize || entry.contentRect;\n            if (data) setProperty();\n          }\n        });\n        this.uniform_resolution_observer.observe(this);\n      }\n    }\n\n    remove_uniform_resolution() {\n      if (this.uniform_resolution_observer) {\n        let { uniform_width, uniform_height } = Uniforms;\n        this.style.removeProperty('--' + uniform_width.name);\n        this.style.removeProperty('--' + uniform_height.name);\n        this.uniform_resolution_observer.unobserve(this);\n        this.uniform_resolution_observer = null;\n      }\n    }\n\n    register_uniform_time() {\n      if (!window.CSS || !window.CSS.registerProperty) {\n        return false;\n      }\n      if (!this.is_uniform_time_registered) {\n        let { uniform_time } = Uniforms;\n        try {\n          CSS.registerProperty({\n            name: '--' + uniform_time.name,\n            syntax: '<number>',\n            initialValue: 0,\n            inherits: true\n          });\n        } catch (e) {}\n        this.is_uniform_time_registered = true;\n      }\n    }\n\n    export({ scale, name, download, detail } = {}) {\n      return new Promise((resolve, reject) => {\n        let variables = get_all_variables(this);\n        let html = this.doodle.innerHTML;\n\n        let { width, height } = this.getBoundingClientRect();\n        scale = parseInt(scale) || 1;\n\n        let w = width * scale;\n        let h = height * scale;\n\n        let svg = `\n          <svg xmlns=\"http://www.w3.org/2000/svg\"\n            preserveAspectRatio=\"none\"\n            viewBox=\"0 0 ${ width } ${ height }\"\n            ${ is_safari() ? '' : `width=\"${ w }px\" height=\"${ h }px\"` }\n          >\n            <foreignObject width=\"100%\" height=\"100%\">\n              <div\n                class=\"host\"\n                xmlns=\"http://www.w3.org/1999/xhtml\"\n                style=\"width: ${ width }px; height: ${ height }px; \"\n              >\n                <style>.host { ${entity(variables)} }</style>\n                ${ html }\n              </div>\n            </foreignObject>\n          </svg>\n        `;\n\n        if (download || detail) {\n          svg_to_png(svg, w, h, scale)\n            .then(({ source, url, blob }) => {\n              resolve({\n                width: w, height: h, svg, blob, source\n              });\n              if (download) {\n                let a = document.createElement('a');\n                a.download = normalize_png_name(name);\n                a.href = url;\n                a.click();\n              }\n            })\n            .catch(error => {\n              reject(error);\n            });\n        } else {\n          resolve({\n            width: w, height: h, svg: svg\n          });\n        }\n      });\n    }\n\n    set_content(selector, styles) {\n      if (styles instanceof Promise) {\n        styles.then(value => {\n          this.set_content(selector, value);\n        });\n      } else {\n        const el = this.shadowRoot.querySelector(selector);\n        el && (el.styleSheet\n          ? (el.styleSheet.cssText = styles )\n          : (el.innerHTML = styles));\n      }\n    }\n  }\n  if (!customElements.get('css-doodle')) {\n    customElements.define('css-doodle', Doodle);\n  }\n}\n\nfunction get_basic_styles() {\n  let { uniform_time } = Uniforms;\n  const inherited_grid_props = get_props(/grid/)\n    .map(n => `${ n }: inherit;`)\n    .join('');\n  return `\n    *, *::after, *::before {\n      box-sizing: border-box;\n    }\n    :host, .host {\n      display: block;\n      visibility: visible;\n      width: auto;\n      height: auto;\n      contain: content;\n      box-sizing: border-box;\n      --${ uniform_time.name }: 0\n    }\n    :host([hidden]), .host[hidden] {\n      display: none\n    }\n    .container {\n      position: relative;\n      width: 100%;\n      height: 100%;\n      display: grid;\n      ${ inherited_grid_props }\n    }\n    cell {\n      position: relative;\n      display: grid;\n      place-items: center\n    }\n    svg {\n      position: absolute;\n      width: 100%;\n      height: 100%\n    }\n    :host([cssd-paused-animation]),\n    :host([cssd-paused-animation]) * {\n      animation-play-state: paused !important\n    }\n  `;\n}\n\nfunction get_grid_styles(grid_obj) {\n  let { x, y } = grid_obj || {};\n  return `\n    :host, .host {\n      grid-template-rows: repeat(${ y }, 1fr);\n      grid-template-columns: repeat(${ x }, 1fr);\n    }\n  `;\n}\n\nfunction get_content(input) {\n  return is_nil(input) ? '' : input;\n}\n\nfunction create_cell(x, y, z, content, child = '') {\n  let id = cell_id(x, y, z);\n  let head = get_content(content['#' + id]);\n  let tail = get_content(child);\n  return `<cell id=\"${id}\">${head}${tail}</cell>`;\n}\n\nfunction create_grid(grid_obj, content) {\n  let { x, y, z } = grid_obj || {};\n  let result = '';\n  if (z == 1) {\n    for (let j = 1; j <= y; ++j) {\n      for (let i = 1; i <= x; ++i) {\n        result += create_cell(i, j, 1, content);\n      }\n    }\n  }\n  else {\n    let child = '';\n    for (let i = z; i >= 1; i--) {\n      let cell = create_cell(1, 1, i, content, child);\n      child = cell;\n    }\n    result = child;\n  }\n  return `<grid class=\"container\">${result}</grid>`;\n}\n\nexport default make_tag_function(rules => {\n  if (typeof document !== 'undefined') {\n    let doodle = document.createElement('css-doodle');\n    if (doodle.update) {\n      doodle.update(rules);\n    }\n    return doodle;\n  }\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}