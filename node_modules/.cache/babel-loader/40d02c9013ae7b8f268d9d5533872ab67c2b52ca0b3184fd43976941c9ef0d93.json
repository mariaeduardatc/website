{"ast":null,"code":"import { scan, iterator } from './tokenizer.js';\nfunction readStatement(iter, token) {\n  let fragment = [];\n  while (iter.next()) {\n    let {\n      curr,\n      next\n    } = iter.get();\n    let isStatementBreak = !next || curr.isSymbol(';') || next.isSymbol('}');\n    fragment.push(curr);\n    if (isStatementBreak) {\n      break;\n    }\n  }\n  if (fragment.length) {\n    token.value = joinToken(fragment);\n  }\n  return token;\n}\nfunction walk(iter, parentToken) {\n  let rules = [];\n  let fragment = [];\n  let tokenType = parentToken && parentToken.type || '';\n  let stack = [];\n  while (iter.next()) {\n    let {\n      prev,\n      curr,\n      next\n    } = iter.get();\n    let isBlockBreak = !next || curr.isSymbol('}');\n    if (tokenType === 'block' && isBlockBreak) {\n      if (!next && rules.length && !curr.isSymbol('}')) {\n        rules[rules.length - 1].value += ';' + curr.value;\n      }\n      parentToken.value = rules;\n      break;\n    } else if (curr.isSymbol('{') && fragment.length && !stack.length) {\n      let selectors = parseSelector(fragment);\n      if (!selectors.length) {\n        continue;\n      }\n      let block = walk(iter, {\n        type: 'block',\n        name: 'unkown',\n        value: []\n      });\n      selectors.forEach(selector => {\n        let newBlock = Object.assign({}, block, {\n          name: selector.name,\n          args: selector.args\n        });\n        rules.push(newBlock);\n      });\n      fragment = [];\n    } else if (curr.isSymbol(':') && fragment.length && !stack.length) {\n      let prop = joinToken(fragment);\n      rules.push(readStatement(iter, {\n        type: 'statement',\n        name: prop,\n        value: ''\n      }));\n      if (tokenType == 'block') {\n        parentToken.value = rules;\n      }\n      fragment = [];\n    } else if (curr.isSymbol(';')) {\n      if (rules.length && fragment.length) {\n        rules[rules.length - 1].value += ';' + joinToken(fragment);\n        fragment = [];\n      }\n    } else {\n      if (curr.isSymbol('(')) {\n        stack.push(curr);\n      }\n      if (curr.isSymbol(')')) {\n        stack.pop();\n      }\n      fragment.push(curr);\n    }\n  }\n  if (rules.length && tokenType == 'block') {\n    parentToken.value = rules;\n  }\n  return tokenType ? parentToken : rules;\n}\nfunction joinToken(tokens) {\n  return tokens.filter((token, i) => {\n    if (token.isSymbol(';') && i === tokens.length - 1) return false;\n    return true;\n  }).map(n => n.value).join('');\n}\nfunction parseSelector(tokens) {\n  let iter = iterator(tokens);\n  let groups = [];\n  let selectorName = '';\n  let args = [];\n  let fragments = [];\n  let stack = [];\n  while (iter.next()) {\n    let {\n      curr,\n      next\n    } = iter.get();\n    if (!selectorName.length && curr.isWord()) {\n      selectorName = curr.value;\n    } else if (curr.isSymbol('(')) {\n      if (stack.length) {\n        fragments.push(curr.value);\n      }\n      stack.push(curr);\n    } else if (curr.isSymbol(')')) {\n      stack.pop();\n      if (stack.length) {\n        fragments.push(curr.value);\n      } else if (fragments.length) {\n        args.push(fragments.join(''));\n        fragments = [];\n      }\n    } else if (curr.isSymbol(',')) {\n      if (stack.length) {\n        args.push(fragments.join(''));\n        fragments = [];\n      } else {\n        if (fragments.length) {\n          args.push(fragments.join(''));\n          fragments = [];\n        }\n        if (selectorName) {\n          groups.push({\n            name: selectorName,\n            args\n          });\n          selectorName = '';\n          args = [];\n          fragments = [];\n        }\n      }\n    } else {\n      fragments.push(curr.value);\n    }\n  }\n  if (selectorName) {\n    groups.push({\n      name: selectorName,\n      args\n    });\n  }\n  return groups.filter((v, i, self) => {\n    let idx = self.findIndex(n => {\n      return n.name === v.name && v.args.join('') == n.args.join('');\n    });\n    return idx === i;\n  });\n}\nfunction parse(source) {\n  let iter = iterator(scan(source));\n  let tokens = walk(iter);\n  return tokens;\n}\nexport default parse;","map":{"version":3,"names":["scan","iterator","readStatement","iter","token","fragment","next","curr","get","isStatementBreak","isSymbol","push","length","value","joinToken","walk","parentToken","rules","tokenType","type","stack","prev","isBlockBreak","selectors","parseSelector","block","name","forEach","selector","newBlock","Object","assign","args","prop","pop","tokens","filter","i","map","n","join","groups","selectorName","fragments","isWord","v","self","idx","findIndex","parse","source"],"sources":["/Users/mariaeduardatc/Documents/GitHub/website/node_modules/css-doodle/src/parser/parse-pattern.js"],"sourcesContent":["import { scan, iterator } from './tokenizer.js';\n\nfunction readStatement(iter, token) {\n  let fragment = [];\n  while (iter.next()) {\n    let { curr, next } = iter.get();\n    let isStatementBreak = !next || curr.isSymbol(';') || next.isSymbol('}');\n    fragment.push(curr);\n    if (isStatementBreak) {\n      break;\n    }\n  }\n  if (fragment.length) {\n    token.value = joinToken(fragment);\n  }\n  return token;\n}\n\nfunction walk(iter, parentToken) {\n  let rules = [];\n  let fragment = [];\n  let tokenType = parentToken && parentToken.type || '';\n  let stack = [];\n\n  while (iter.next()) {\n    let { prev, curr, next } = iter.get();\n    let isBlockBreak = !next || curr.isSymbol('}');\n    if (tokenType === 'block' && isBlockBreak) {\n      if (!next && rules.length && !curr.isSymbol('}')) {\n        rules[rules.length - 1].value += (';' + curr.value);\n      }\n      parentToken.value = rules;\n      break;\n    }\n    else if (curr.isSymbol('{') && fragment.length && !stack.length) {\n      let selectors = parseSelector(fragment);\n      if (!selectors.length) {\n        continue;\n      }\n      let block = walk(iter, {\n        type: 'block',\n        name: 'unkown',\n        value: []\n      });\n\n      selectors.forEach(selector => {\n        let newBlock = Object.assign({}, block, {\n          name: selector.name,\n          args: selector.args\n        });\n        rules.push(newBlock);\n      });\n      fragment = [];\n    }\n    else if (curr.isSymbol(':') && fragment.length && !stack.length) {\n      let prop = joinToken(fragment);\n      rules.push(readStatement(iter, {\n        type: 'statement',\n        name: prop,\n        value: ''\n      }));\n      if (tokenType == 'block') {\n        parentToken.value = rules;\n      }\n      fragment = [];\n    }\n    else if (curr.isSymbol(';')) {\n      if (rules.length && fragment.length) {\n        rules[rules.length - 1].value += (';' + joinToken(fragment));\n        fragment = [];\n      }\n    } else {\n      if (curr.isSymbol('(')) {\n        stack.push(curr);\n      }\n      if (curr.isSymbol(')')) {\n        stack.pop();\n      }\n      fragment.push(curr);\n    }\n  }\n\n  if (rules.length && tokenType == 'block') {\n    parentToken.value = rules;\n  }\n  return tokenType ? parentToken : rules;\n}\n\nfunction joinToken(tokens) {\n  return tokens\n    .filter((token, i) => {\n      if (token.isSymbol(';') && i === tokens.length - 1) return false;\n      return true;\n    })\n    .map(n => n.value).join('');\n}\n\nfunction parseSelector(tokens) {\n  let iter = iterator(tokens);\n  let groups = [];\n  let selectorName = '';\n  let args = [];\n  let fragments = [];\n  let stack = [];\n  while (iter.next()) {\n    let { curr, next } = iter.get();\n    if (!selectorName.length && curr.isWord()) {\n      selectorName = curr.value;\n    }\n    else if (curr.isSymbol('(')) {\n      if (stack.length) {\n        fragments.push(curr.value);\n      }\n      stack.push(curr);\n    }\n    else if (curr.isSymbol(')')) {\n      stack.pop();\n      if (stack.length) {\n        fragments.push(curr.value);\n      } else if (fragments.length) {\n        args.push(fragments.join(''));\n        fragments = [];\n      }\n    }\n    else if (curr.isSymbol(',')) {\n      if (stack.length) {\n        args.push(fragments.join(''));\n        fragments = [];\n      } else {\n        if (fragments.length) {\n          args.push(fragments.join(''));\n          fragments = [];\n        }\n        if (selectorName) {\n          groups.push({\n            name: selectorName,\n            args\n          });\n          selectorName = '';\n          args = [];\n          fragments = [];\n        }\n      }\n    }\n    else {\n      fragments.push(curr.value);\n    }\n  }\n\n  if (selectorName) {\n    groups.push({\n      name: selectorName,\n      args\n    });\n  }\n\n  return groups.filter((v, i, self) => {\n    let idx = self.findIndex(n => {\n      return (n.name === v.name && v.args.join('') == n.args.join(''));\n    });\n    return idx === i;\n  });\n}\n\nfunction parse(source) {\n  let iter = iterator(scan(source));\n  let tokens = walk(iter);\n  return tokens;\n}\n\nexport default parse;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}