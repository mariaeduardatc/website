{"ast":null,"code":"import { is_empty } from '../utils/index.js';\nimport { scan, iterator } from './tokenizer.js';\nfunction parse(input) {\n  let option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    symbol: ',',\n    noSpace: false,\n    verbose: false\n  };\n  let group = [];\n  let skip = false;\n  let tokens = [];\n  let parenStack = [];\n  let quoteStack = [];\n  let lastGroupName = '';\n  if (is_empty(input)) {\n    return group;\n  }\n  let iter = iterator(scan(input));\n  function isSeperator(token) {\n    let symbol = option.symbol || [','];\n    if (!Array.isArray(symbol)) {\n      symbol = [symbol];\n    }\n    if (option.noSpace) {\n      return token.isSymbol(...symbol);\n    }\n    return token.isSymbol(...symbol) || token.isSpace();\n  }\n  function addGroup(tokens) {\n    let value = joinTokens(tokens);\n    if (option.verbose) {\n      if (lastGroupName.length || value.length) {\n        group.push({\n          group: lastGroupName,\n          value\n        });\n      }\n    } else {\n      group.push(value);\n    }\n  }\n  while (iter.next()) {\n    let {\n      prev,\n      curr,\n      next\n    } = iter.get();\n    if (curr.isSymbol('(')) {\n      parenStack.push(curr.value);\n    }\n    if (curr.isSymbol(')')) {\n      parenStack.pop();\n    }\n    if (curr.status === 'open') {\n      quoteStack.push(curr.value);\n    }\n    if (curr.status === 'close') {\n      quoteStack.pop();\n    }\n    let emptyStack = !parenStack.length && !quoteStack.length;\n    if (emptyStack) {\n      let isNextSpace = option.noSpace && curr.isSpace() && isSeperator(next);\n      let isPrevSpace = option.noSpace && curr.isSpace() && isSeperator(prev);\n      if (isNextSpace || isPrevSpace) continue;\n    }\n    if (emptyStack && isSeperator(curr)) {\n      let groupName = lastGroupName;\n      addGroup(tokens);\n      lastGroupName = curr.value;\n      tokens = [];\n    } else {\n      tokens.push(curr);\n    }\n  }\n  if (tokens.length) {\n    addGroup(tokens);\n  }\n  return group;\n}\nfunction joinTokens(tokens) {\n  return tokens.map(n => n.value).join('');\n}\nexport default parse;","map":{"version":3,"names":["is_empty","scan","iterator","parse","input","option","symbol","noSpace","verbose","group","skip","tokens","parenStack","quoteStack","lastGroupName","iter","isSeperator","token","Array","isArray","isSymbol","isSpace","addGroup","value","joinTokens","length","push","next","prev","curr","get","pop","status","emptyStack","isNextSpace","isPrevSpace","groupName","map","n","join"],"sources":["/Users/mariaeduardatc/Documents/GitHub/website/node_modules/css-doodle/src/parser/parse-value-group.js"],"sourcesContent":["import { is_empty } from '../utils/index.js';\nimport { scan, iterator } from './tokenizer.js';\n\nfunction parse(input, option = {symbol: ',', noSpace: false, verbose: false }) {\n  let group = [];\n  let skip = false;\n  let tokens = [];\n  let parenStack = [];\n  let quoteStack = [];\n  let lastGroupName = '';\n\n  if (is_empty(input)) {\n    return group;\n  }\n\n  let iter = iterator(scan(input));\n\n  function isSeperator(token) {\n    let symbol = option.symbol || [','];\n    if (!Array.isArray(symbol)) {\n      symbol = [symbol];\n    }\n    if (option.noSpace) {\n      return token.isSymbol(...symbol);\n    }\n    return token.isSymbol(...symbol) || token.isSpace();\n  }\n\n  function addGroup(tokens) {\n    let value = joinTokens(tokens);\n    if (option.verbose) {\n      if (lastGroupName.length || value.length) {\n        group.push({ group: lastGroupName, value });\n      }\n    } else {\n      group.push(value);\n    }\n  }\n\n  while (iter.next()) {\n    let { prev, curr, next }  = iter.get();\n    if (curr.isSymbol('(')) {\n      parenStack.push(curr.value);\n    }\n    if (curr.isSymbol(')')) {\n      parenStack.pop();\n    }\n    if (curr.status === 'open') {\n      quoteStack.push(curr.value);\n    }\n    if (curr.status === 'close') {\n      quoteStack.pop();\n    }\n    let emptyStack = (!parenStack.length && !quoteStack.length);\n    if (emptyStack) {\n      let isNextSpace = option.noSpace && curr.isSpace() && isSeperator(next);\n      let isPrevSpace = option.noSpace && curr.isSpace() && isSeperator(prev);\n      if (isNextSpace || isPrevSpace) continue;\n    }\n    if (emptyStack && isSeperator(curr)) {\n      let groupName = lastGroupName;\n      addGroup(tokens);\n      lastGroupName = curr.value;\n      tokens = [];\n    } else {\n      tokens.push(curr);\n    }\n  }\n\n  if (tokens.length) {\n    addGroup(tokens);\n  }\n\n  return group;\n}\n\nfunction joinTokens(tokens) {\n  return tokens.map(n => n.value).join('');\n}\n\nexport default parse;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}