{"ast":null,"code":"import { create_svg_url, normalize_svg } from './utils/svg.js';\nimport { generate_svg } from './generator/svg.js';\nimport { cell_id, is_letter, is_nil, is_empty, add_alias, unique_id, lerp } from './utils/index.js';\nimport { lazy, clamp, sequence, get_value } from './utils/index.js';\nimport { by_unit, by_charcode } from './utils/transform.js';\nimport { last } from './utils/list.js';\nimport calc from './calc.js';\nimport { memo } from './utils/memo.js';\nimport { expand } from './utils/expand.js';\nimport Stack from './utils/stack.js';\nimport Noise from './utils/noise.js';\nimport get_named_arguments from './utils/get-named-arguments.js';\nimport { shapes, create_shape_points } from './generator/shapes.js';\nimport parse_value_group from './parser/parse-value-group.js';\nimport parse_shape_commands from './parser/parse-shape-commands.js';\nimport parse_svg from './parser/parse-svg.js';\nimport parse_svg_path from './parser/parse-svg-path.js';\nimport parse_compound_value from './parser/parse-compound-value.js';\nimport * as Uniforms from './uniforms.js';\nfunction make_sequence(c) {\n  return lazy(function (_, n) {\n    for (var _len = arguments.length, actions = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      actions[_key - 2] = arguments[_key];\n    }\n    if (!actions || !n) return '';\n    let count = get_value(n());\n    let evaluated = count;\n    if (/\\D/.test(count) && !/\\d+[x-]\\d+/.test(count)) {\n      evaluated = calc(count);\n      if (evaluated === 0) {\n        evaluated = count;\n      }\n    }\n    let signature = Math.random();\n    return sequence(evaluated, function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return actions.map(action => {\n        return get_value(action(...args, signature));\n      }).join(',');\n    }).join(c);\n  });\n}\nfunction push_stack(context, name, value) {\n  if (!context[name]) context[name] = new Stack(1024);\n  context[name].push(value);\n  return value;\n}\nfunction flip_value(num) {\n  return -1 * num;\n}\nfunction map2d(value, min, max) {\n  let amp = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n  let dimension = 2;\n  let v = Math.sqrt(dimension / 4) * amp;\n  let [ma, mb] = [-v, v];\n  return lerp((value - ma) / (mb - ma), min * amp, max * amp);\n}\nfunction compute(op, a, b) {\n  switch (op) {\n    case '+':\n      return a + b;\n    case '-':\n      return a - b;\n    case '*':\n      return a * b;\n    case '/':\n      return a / b;\n    case '%':\n      return a % b;\n    default:\n      return 0;\n  }\n}\nfunction calc_with(base) {\n  return v => {\n    if (is_empty(v) || is_empty(base)) {\n      return base;\n    }\n    if (/^[+*-\\/%][\\-.\\d\\s]/.test(v)) {\n      let op = v[0];\n      let {\n        unit = '',\n        value\n      } = parse_compound_value(v.substr(1).trim() || 0);\n      return compute(op, base, value) + unit;\n    } else if (/[+*-\\/%]$/.test(v)) {\n      let op = v.substr(-1);\n      let {\n        unit = '',\n        value\n      } = parse_compound_value(v.substr(0, v.length - 1).trim() || 0);\n      return compute(op, value, base) + unit;\n    } else {\n      let {\n        unit = '',\n        value\n      } = parse_compound_value(v || 0);\n      return base + value + unit;\n    }\n  };\n}\nconst Expose = add_alias({\n  i(_ref) {\n    let {\n      count\n    } = _ref;\n    return calc_with(count);\n  },\n  y(_ref2) {\n    let {\n      y\n    } = _ref2;\n    return calc_with(y);\n  },\n  x(_ref3) {\n    let {\n      x\n    } = _ref3;\n    return calc_with(x);\n  },\n  z(_ref4) {\n    let {\n      z\n    } = _ref4;\n    return calc_with(z);\n  },\n  I(_ref5) {\n    let {\n      grid\n    } = _ref5;\n    return calc_with(grid.count);\n  },\n  Y(_ref6) {\n    let {\n      grid\n    } = _ref6;\n    return calc_with(grid.y);\n  },\n  X(_ref7) {\n    let {\n      grid\n    } = _ref7;\n    return calc_with(grid.x);\n  },\n  Z(_ref8) {\n    let {\n      grid\n    } = _ref8;\n    return calc_with(grid.z);\n  },\n  id(_ref9) {\n    let {\n      x,\n      y,\n      z\n    } = _ref9;\n    return _ => cell_id(x, y, z);\n  },\n  dx(_ref10) {\n    let {\n      x,\n      grid\n    } = _ref10;\n    return n => {\n      n = Number(n) || 0;\n      return x - .5 - n - grid.x / 2;\n    };\n  },\n  dy(_ref11) {\n    let {\n      y,\n      grid\n    } = _ref11;\n    return n => {\n      n = Number(n) || 0;\n      return y - .5 - n - grid.y / 2;\n    };\n  },\n  n(_ref12) {\n    let {\n      extra\n    } = _ref12;\n    let lastExtra = last(extra);\n    return lastExtra ? calc_with(lastExtra[0]) : '@n';\n  },\n  nx(_ref13) {\n    let {\n      extra\n    } = _ref13;\n    let lastExtra = last(extra);\n    return lastExtra ? calc_with(lastExtra[1]) : '@nx';\n  },\n  ny(_ref14) {\n    let {\n      extra\n    } = _ref14;\n    let lastExtra = last(extra);\n    return lastExtra ? calc_with(lastExtra[2]) : '@ny';\n  },\n  N(_ref15) {\n    let {\n      extra\n    } = _ref15;\n    let lastExtra = last(extra);\n    return lastExtra ? calc_with(lastExtra[3]) : '@N';\n  },\n  m: make_sequence(','),\n  M: make_sequence(' '),\n  µ: make_sequence(''),\n  p(_ref16) {\n    let {\n      context,\n      pick\n    } = _ref16;\n    return expand(function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      if (!args.length) {\n        args = context.last_pick_args || [];\n      }\n      let picked = pick(args);\n      context.last_pick_args = args;\n      return push_stack(context, 'last_pick', picked);\n    });\n  },\n  P(_ref17) {\n    let {\n      context,\n      pick,\n      position\n    } = _ref17;\n    let counter = 'P-counter' + position;\n    return expand(function () {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n      let normal = true;\n      if (!args.length) {\n        args = context.last_pick_args || [];\n        normal = false;\n      }\n      let stack = context.last_pick;\n      let last = stack ? stack.last(1) : '';\n      if (normal) {\n        if (!context[counter]) {\n          context[counter] = {};\n        }\n        last = context[counter].last_pick;\n      }\n      if (args.length > 1) {\n        let i = args.findIndex(n => n === last);\n        if (i !== -1) {\n          args.splice(i, 1);\n        }\n      }\n      let picked = pick(args);\n      context.last_pick_args = args;\n      if (normal) {\n        context[counter].last_pick = picked;\n      }\n      return push_stack(context, 'last_pick', picked);\n    });\n  },\n  pl(_ref18) {\n    let {\n      context,\n      extra,\n      position\n    } = _ref18;\n    let lastExtra = last(extra);\n    let sig = lastExtra ? last(lastExtra) : '';\n    let counter = 'pl-counter' + position + sig;\n    return expand(function () {\n      if (!context[counter]) context[counter] = 0;\n      context[counter] += 1;\n      let max = arguments.length;\n      let idx = lastExtra && lastExtra[6];\n      if (is_nil(idx)) idx = context[counter];\n      let pos = (idx - 1) % max;\n      let value = pos < 0 || arguments.length <= pos ? undefined : arguments[pos];\n      return push_stack(context, 'last_pick', value);\n    });\n  },\n  pr(_ref19) {\n    let {\n      context,\n      extra,\n      position\n    } = _ref19;\n    let lastExtra = last(extra);\n    let sig = lastExtra ? last(lastExtra) : '';\n    let counter = 'pr-counter' + position + sig;\n    return expand(function () {\n      if (!context[counter]) context[counter] = 0;\n      context[counter] += 1;\n      let max = arguments.length;\n      let idx = lastExtra && lastExtra[6];\n      if (is_nil(idx)) idx = context[counter];\n      let pos = (idx - 1) % max;\n      let value = max - pos - 1 < 0 || arguments.length <= max - pos - 1 ? undefined : arguments[max - pos - 1];\n      return push_stack(context, 'last_pick', value);\n    });\n  },\n  pd(_ref20) {\n    let {\n      context,\n      extra,\n      position,\n      shuffle\n    } = _ref20;\n    let lastExtra = last(extra);\n    let sig = lastExtra ? last(lastExtra) : '';\n    let counter = 'pd-counter' + position + sig;\n    let values = 'pd-values' + position + sig;\n    ;\n    return expand(function () {\n      if (!context[counter]) context[counter] = 0;\n      context[counter] += 1;\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n      if (!context[values]) {\n        context[values] = shuffle(args || []);\n      }\n      let max = args.length;\n      let idx = lastExtra && lastExtra[6];\n      if (is_nil(idx)) idx = context[counter];\n      let pos = (idx - 1) % max;\n      let value = context[values][pos];\n      return push_stack(context, 'last_pick', value);\n    });\n  },\n  lp(_ref21) {\n    let {\n      context\n    } = _ref21;\n    return function () {\n      let n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      let stack = context.last_pick;\n      return stack ? stack.last(n) : '';\n    };\n  },\n  r(_ref22) {\n    let {\n      context,\n      rand\n    } = _ref22;\n    return function () {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n      let transform = args.every(is_letter) ? by_charcode : by_unit;\n      let value = transform(rand)(...args);\n      return push_stack(context, 'last_rand', value);\n    };\n  },\n  rn(_ref23) {\n    let {\n      x,\n      y,\n      context,\n      position,\n      grid,\n      extra,\n      random\n    } = _ref23;\n    let counter = 'noise-2d' + position;\n    let counterX = counter + 'offset-x';\n    let counterY = counter + 'offset-y';\n    let [ni, nx, ny, nm, NX, NY] = last(extra) || [];\n    let isSeqContext = ni && nm;\n    return function () {\n      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n      let {\n        from = 0,\n        to = from,\n        frequency = 1,\n        scale = 1,\n        octave = 1\n      } = get_named_arguments(args, ['from', 'to', 'frequency', 'scale', 'octave']);\n      frequency = clamp(frequency, 0, Infinity);\n      scale = clamp(scale, 0, Infinity);\n      octave = clamp(octave, 1, 100);\n      if (args.length == 1) [from, to] = [0, from];\n      if (!context[counter]) context[counter] = new Noise();\n      if (!context[counterX]) context[counterX] = random();\n      if (!context[counterY]) context[counterY] = random();\n      let transform = is_letter(from) && is_letter(to) ? by_charcode : by_unit;\n      let noise2d = context[counter];\n      let offsetX = context[counterX];\n      let offsetY = context[counterY];\n      let _x = (isSeqContext ? (nx - 1) / NX : (x - 1) / grid.x) + offsetX;\n      let _y = (isSeqContext ? (ny - 1) / NY : (y - 1) / grid.y) + offsetY;\n\n      // 1-dimentional\n      if (NX <= 1 || grid.x <= 1) _x = 0;\n      if (NY <= 1 || grid.y <= 1) _y = 0;\n\n      // 1x1\n      if (_x == 0 && _y == 0) {\n        _x = offsetX;\n        _y = offsetY;\n      }\n      let t = noise2d.noise(_x * frequency, _y * frequency, 0) * scale;\n      for (let i = 1; i < octave; ++i) {\n        let i2 = i * 2;\n        t += noise2d.noise(_x * frequency * i2, _y * frequency * i2, 0) * (scale / i2);\n      }\n      let fn = transform((from, to) => map2d(t, from, to, scale));\n      return push_stack(context, 'last_rand', fn(from, to));\n    };\n  },\n  lr(_ref24) {\n    let {\n      context\n    } = _ref24;\n    return function () {\n      let n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      let stack = context.last_rand;\n      return stack ? stack.last(n) : '';\n    };\n  },\n  stripe() {\n    return function () {\n      for (var _len8 = arguments.length, input = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        input[_key8] = arguments[_key8];\n      }\n      let colors = input.map(get_value);\n      let max = colors.length;\n      let default_count = 0;\n      let custom_sizes = [];\n      let prev;\n      if (!max) {\n        return '';\n      }\n      colors.forEach(step => {\n        let [_, size] = parse_value_group(step);\n        if (size !== undefined) custom_sizes.push(size);else default_count += 1;\n      });\n      let default_size = custom_sizes.length ? `(100% - ${custom_sizes.join(' - ')}) / ${default_count}` : `100% / ${max}`;\n      return colors.map((step, i) => {\n        if (custom_sizes.length) {\n          let [color, size] = parse_value_group(step);\n          let prefix = prev ? prev + ' + ' : '';\n          prev = prefix + (size !== undefined ? size : default_size);\n          return `${color} 0 calc(${prev})`;\n        }\n        return `${step} 0 ${100 / max * (i + 1)}%`;\n      }).join(',');\n    };\n  },\n  calc() {\n    return (value, context) => {\n      return calc(get_value(value), context);\n    };\n  },\n  hex() {\n    return value => parseInt(get_value(value)).toString(16);\n  },\n  svg: lazy(function (_) {\n    for (var _len9 = arguments.length, args = new Array(_len9 > 1 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) {\n      args[_key9 - 1] = arguments[_key9];\n    }\n    let value = args.map(input => get_value(input())).join(',');\n    if (!value.startsWith('<')) {\n      let parsed = parse_svg(value);\n      value = generate_svg(parsed);\n    }\n    let svg = normalize_svg(value);\n    return create_svg_url(svg);\n  }),\n  'svg-filter': lazy(function (upstream) {\n    for (var _len10 = arguments.length, args = new Array(_len10 > 1 ? _len10 - 1 : 0), _key10 = 1; _key10 < _len10; _key10++) {\n      args[_key10 - 1] = arguments[_key10];\n    }\n    let values = args.map(input => get_value(input()));\n    let value = values.join(',');\n    let id = unique_id('filter-');\n    // shorthand\n    if (values.every(n => /^[\\-\\d.]/.test(n) || /^(\\w+)/.test(n) && !/[{}<>]/.test(n))) {\n      let {\n        frequency,\n        scale,\n        octave,\n        seed = upstream.seed,\n        blur,\n        erode,\n        dilate\n      } = get_named_arguments(values, ['frequency', 'scale', 'octave', 'seed', 'blur', 'erode', 'dilate']);\n      value = `\n        x: -20%;\n        y: -20%;\n        width: 140%;\n        height: 140%;\n      `;\n      if (!is_nil(dilate)) {\n        value += `\n          feMorphology {\n            operator: dilate;\n            radius: ${dilate};\n          }\n        `;\n      }\n      if (!is_nil(erode)) {\n        value += `\n          feMorphology {\n            operator: erode;\n            radius: ${erode};\n          }\n        `;\n      }\n      if (!is_nil(blur)) {\n        value += `\n          feGaussianBlur {\n            stdDeviation: ${blur};\n          }\n        `;\n      }\n      if (!is_nil(frequency)) {\n        let [bx, by = bx] = parse_value_group(frequency);\n        octave = octave ? `numOctaves: ${octave};` : '';\n        value += `\n          feTurbulence {\n            type: fractalNoise;\n            baseFrequency: ${bx} ${by};\n            seed: ${seed};\n            ${octave}\n          }\n        `;\n        if (scale) {\n          value += `\n            feDisplacementMap {\n              in: SourceGraphic;\n              scale: ${scale};\n            }\n          `;\n        }\n      }\n    }\n    // new svg syntax\n    if (!value.startsWith('<')) {\n      let parsed = parse_svg(value, {\n        type: 'block',\n        name: 'filter'\n      });\n      value = generate_svg(parsed);\n    }\n    let svg = normalize_svg(value).replace(/<filter([\\s>])/, `<filter id=\"${id}\"$1`);\n    return create_svg_url(svg, id);\n  }),\n  'svg-pattern': lazy(function (_) {\n    for (var _len11 = arguments.length, args = new Array(_len11 > 1 ? _len11 - 1 : 0), _key11 = 1; _key11 < _len11; _key11++) {\n      args[_key11 - 1] = arguments[_key11];\n    }\n    let value = args.map(input => get_value(input())).join(',');\n    let parsed = parse_svg(`\n      viewBox: 0 0 1 1;\n      preserveAspectRatio: xMidYMid slice;\n      rect {\n        width, height: 100%;\n        fill: defs pattern { ${value} }\n      }\n    `);\n    let svg = generate_svg(parsed);\n    return create_svg_url(svg);\n  }),\n  'svg-polygon': lazy(function (_) {\n    for (var _len12 = arguments.length, args = new Array(_len12 > 1 ? _len12 - 1 : 0), _key12 = 1; _key12 < _len12; _key12++) {\n      args[_key12 - 1] = arguments[_key12];\n    }\n    let value = args.map(input => get_value(input())).join(',');\n    let config = parse_shape_commands(value);\n    delete config.frame;\n    config['unit'] = 'none';\n    config['stroke-width'] ??= .01;\n    config['stroke'] ??= 'currentColor';\n    config['fill'] ??= 'none';\n    let points = `points: ${create_shape_points(config, {\n      min: 3,\n      max: 65536\n    })};`;\n    let props = '';\n    for (let name of Object.keys(config)) {\n      if (/^(stroke|fill|clip|marker|mask|animate|draw)/.test(name)) {\n        props += `${name}: ${config[name]};`;\n      }\n    }\n    ;\n    let parsed = parse_svg(`\n      viewBox: -1 -1 2 2 p ${Number(config['stroke-width']) / 2};\n      polygon {\n        ${props} ${points}\n      }\n    `);\n    return create_svg_url(generate_svg(parsed));\n  }),\n  var() {\n    return value => `var(${get_value(value)})`;\n  },\n  ut() {\n    return value => `var(--${Uniforms.uniform_time.name})`;\n  },\n  uw() {\n    return value => `var(--${Uniforms.uniform_width.name})`;\n  },\n  uh() {\n    return value => `var(--${Uniforms.uniform_height.name})`;\n  },\n  ux() {\n    return value => `var(--${Uniforms.uniform_mousex.name})`;\n  },\n  uy() {\n    return value => `var(--${Uniforms.uniform_mousey.name})`;\n  },\n  plot(_ref25) {\n    let {\n      count,\n      context,\n      extra,\n      position,\n      grid\n    } = _ref25;\n    let key = 'offset-points' + position;\n    let lastExtra = last(extra);\n    return commands => {\n      let [idx = count, _, __, max = grid.count] = lastExtra || [];\n      if (!context[key]) {\n        let config = parse_shape_commands(commands);\n        delete config['fill'];\n        delete config['fill-rule'];\n        delete config['frame'];\n        config.points = max;\n        context[key] = create_shape_points(config, {\n          min: 1,\n          max: 65536\n        });\n      }\n      return context[key][idx - 1];\n    };\n  },\n  Plot(_ref26) {\n    let {\n      count,\n      context,\n      extra,\n      position,\n      grid\n    } = _ref26;\n    let key = 'Offset-points' + position;\n    let lastExtra = last(extra);\n    return commands => {\n      let [idx = count, _, __, max = grid.count] = lastExtra || [];\n      if (!context[key]) {\n        let config = parse_shape_commands(commands);\n        delete config['fill'];\n        delete config['fill-rule'];\n        delete config['frame'];\n        config.points = max;\n        config.unit = config.unit || 'none';\n        context[key] = create_shape_points(config, {\n          min: 1,\n          max: 65536\n        });\n      }\n      return context[key][idx - 1];\n    };\n  },\n  shape() {\n    return memo('shape-function', function () {\n      let type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n      type = String(type).trim();\n      let points = [];\n      if (type.length) {\n        for (var _len13 = arguments.length, args = new Array(_len13 > 1 ? _len13 - 1 : 0), _key13 = 1; _key13 < _len13; _key13++) {\n          args[_key13 - 1] = arguments[_key13];\n        }\n        if (typeof shapes[type] === 'function') {\n          points = shapes[type](args);\n        } else {\n          let commands = type;\n          let rest = args.join(',');\n          if (rest.length) {\n            commands = type + ',' + rest;\n          }\n          let config = parse_shape_commands(commands);\n          points = create_shape_points(config, {\n            min: 3,\n            max: 3600\n          });\n        }\n      }\n      return `polygon(${points.join(',')})`;\n    });\n  },\n  doodle() {\n    return value => value;\n  },\n  shaders() {\n    return value => value;\n  },\n  canvas() {\n    return value => value;\n  },\n  pattern() {\n    return value => value;\n  },\n  invert() {\n    return commands => {\n      let parsed = parse_svg_path(commands);\n      if (!parsed.valid) return commands;\n      return parsed.commands.map(_ref27 => {\n        let {\n          name,\n          value\n        } = _ref27;\n        switch (name) {\n          case 'v':\n            return 'h' + value.join(' ');\n          case 'V':\n            return 'H' + value.join(' ');\n          case 'h':\n            return 'v' + value.join(' ');\n          case 'H':\n            return 'V' + value.join(' ');\n          default:\n            return name + value.join(' ');\n        }\n      }).join(' ');\n    };\n  },\n  flipH() {\n    return commands => {\n      let parsed = parse_svg_path(commands);\n      if (!parsed.valid) return commands;\n      return parsed.commands.map(_ref28 => {\n        let {\n          name,\n          value\n        } = _ref28;\n        switch (name) {\n          case 'h':\n          case 'H':\n            return name + value.map(flip_value).join(' ');\n          default:\n            return name + value.join(' ');\n        }\n      }).join(' ');\n    };\n  },\n  flipV() {\n    return commands => {\n      let parsed = parse_svg_path(commands);\n      if (!parsed.valid) return commands;\n      return parsed.commands.map(_ref29 => {\n        let {\n          name,\n          value\n        } = _ref29;\n        switch (name) {\n          case 'v':\n          case 'V':\n            return name + value.map(flip_value).join(' ');\n          default:\n            return name + value.join(' ');\n        }\n      }).join(' ');\n    };\n  },\n  flip() {\n    let flipH = Expose.flipH(...arguments);\n    let flipV = Expose.flipV(...arguments);\n    return commands => {\n      return flipV(flipH(commands));\n    };\n  },\n  reverse() {\n    return function () {\n      for (var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {\n        args[_key14] = arguments[_key14];\n      }\n      let commands = args.map(get_value);\n      let parsed = parse_svg_path(commands.join(','));\n      if (parsed.valid) {\n        let result = [];\n        for (let i = parsed.commands.length - 1; i >= 0; --i) {\n          let {\n            name,\n            value\n          } = parsed.commands[i];\n          result.push(name + value.join(' '));\n        }\n        return result.join(' ');\n      }\n      return commands.reverse();\n    };\n  },\n  cycle() {\n    return function () {\n      for (var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {\n        args[_key15] = arguments[_key15];\n      }\n      args = args.map(n => '(' + n + ')');\n      let list = [];\n      let separator;\n      if (args.length == 1) {\n        separator = ' ';\n        ;\n        list = parse_value_group(args[0], {\n          symbol: separator\n        });\n      } else {\n        separator = ',';\n        list = parse_value_group(args.map(get_value).join(separator), {\n          symbol: separator\n        });\n      }\n      list = list.map(n => n.replace(/^\\(|\\)$/g, ''));\n      let size = list.length - 1;\n      let result = [list.join(separator)];\n      // Just ignore the performance\n      for (let i = 0; i < size; ++i) {\n        let item = list.shift();\n        list.push(item);\n        result.push(list.join(separator));\n      }\n      return result;\n    };\n  },\n  mirror() {\n    return function () {\n      for (var _len16 = arguments.length, args = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {\n        args[_key16] = arguments[_key16];\n      }\n      for (let i = args.length - 1; i >= 0; --i) {\n        args.push(args[i]);\n      }\n      return args;\n    };\n  },\n  Mirror() {\n    return function () {\n      for (var _len17 = arguments.length, args = new Array(_len17), _key17 = 0; _key17 < _len17; _key17++) {\n        args[_key17] = arguments[_key17];\n      }\n      for (let i = args.length - 2; i >= 0; --i) {\n        args.push(args[i]);\n      }\n      return args;\n    };\n  },\n  code() {\n    return function () {\n      for (var _len18 = arguments.length, args = new Array(_len18), _key18 = 0; _key18 < _len18; _key18++) {\n        args[_key18] = arguments[_key18];\n      }\n      return args.map(code => String.fromCharCode(code));\n    };\n  },\n  once(_ref30) {\n    let {\n      context,\n      extra,\n      position\n    } = _ref30;\n    let counter = 'once-counter' + position;\n    return function () {\n      if (is_nil(context[counter])) {\n        for (var _len19 = arguments.length, args = new Array(_len19), _key19 = 0; _key19 < _len19; _key19++) {\n          args[_key19] = arguments[_key19];\n        }\n        context[counter] = args;\n      }\n      return context[counter];\n    };\n  },\n  raw(_ref31) {\n    let {\n      rules\n    } = _ref31;\n    return function () {\n      let raw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n      try {\n        let cut = raw.substring(raw.indexOf(',') + 1, raw.lastIndexOf('\")'));\n        if (raw.startsWith('${doodle') && raw.endsWith('}')) {\n          let key = raw.substring(2, raw.length - 1);\n          let doodles = rules.doodles;\n          if (doodles && doodles[key]) {\n            return `<css-doodle>${doodles[key].doodle}</css-doodle>`;\n          }\n        }\n        if (raw.startsWith('url(\"data:image/svg+xml;utf8')) {\n          return decodeURIComponent(cut);\n        }\n        /* future forms */\n        if (raw.startsWith('url(\"data:image/svg+xml;base64')) {\n          return atob(cut);\n        }\n        if (raw.startsWith('url(\"data:image/png;base64')) {\n          return `<img src=\"${raw}\" alt=\"\" />`;\n        }\n      } catch (e) {\n        /* ignore */\n      }\n      return raw;\n    };\n  }\n}, {\n  'index': 'i',\n  'col': 'x',\n  'row': 'y',\n  'depth': 'z',\n  'rand': 'r',\n  'pick': 'p',\n  'pn': 'pl',\n  'pnr': 'pr',\n  // error prone\n  'stripes': 'stripe',\n  'strip': 'stripe',\n  'patern': 'pattern',\n  'flipv': 'flipV',\n  'fliph': 'flipH',\n  // legacy names, keep them before 1.0\n  't': 'ut',\n  'filter': 'svg-filter',\n  'last-rand': 'lr',\n  'last-pick': 'lp',\n  'multiple': 'm',\n  'multi': 'm',\n  'rep': 'µ',\n  'repeat': 'µ',\n  'ms': 'M',\n  's': 'I',\n  'size': 'I',\n  'sx': 'X',\n  'size-x': 'X',\n  'size-col': 'X',\n  'max-col': 'X',\n  'sy': 'Y',\n  'size-y': 'Y',\n  'size-row': 'Y',\n  'max-row': 'Y',\n  'sz': 'Z',\n  'size-z': 'Z',\n  'size-depth': 'Z',\n  'Svg': 'svg',\n  'pick-by-turn': 'pl',\n  'pick-n': 'pl',\n  'pick-d': 'pd',\n  'offset': 'plot',\n  'Offset': 'Plot',\n  'point': 'plot',\n  'Point': 'Plot',\n  'paint': 'canvas',\n  'unicode': 'code'\n});\nexport default Expose;","map":{"version":3,"names":["create_svg_url","normalize_svg","generate_svg","cell_id","is_letter","is_nil","is_empty","add_alias","unique_id","lerp","lazy","clamp","sequence","get_value","by_unit","by_charcode","last","calc","memo","expand","Stack","Noise","get_named_arguments","shapes","create_shape_points","parse_value_group","parse_shape_commands","parse_svg","parse_svg_path","parse_compound_value","Uniforms","make_sequence","c","_","n","actions","count","evaluated","test","signature","Math","random","args","map","action","join","push_stack","context","name","value","push","flip_value","num","map2d","min","max","amp","dimension","v","sqrt","ma","mb","compute","op","a","b","calc_with","base","unit","substr","trim","length","Expose","i","y","x","z","I","grid","Y","X","Z","id","dx","Number","dy","extra","lastExtra","nx","ny","N","m","M","µ","p","pick","last_pick_args","picked","P","position","counter","normal","stack","last_pick","findIndex","splice","pl","sig","idx","pos","pr","pd","shuffle","values","lp","r","rand","transform","every","rn","counterX","counterY","ni","nm","NX","NY","isSeqContext","from","to","frequency","scale","octave","Infinity","noise2d","offsetX","offsetY","_x","_y","t","noise","i2","fn","lr","last_rand","stripe","input","colors","default_count","custom_sizes","prev","forEach","step","size","undefined","default_size","color","prefix","hex","parseInt","toString","svg","startsWith","parsed","upstream","seed","blur","erode","dilate","bx","by","type","replace","config","frame","points","props","Object","keys","var","ut","uniform_time","uw","uniform_width","uh","uniform_height","ux","uniform_mousex","uy","uniform_mousey","plot","key","commands","__","Plot","shape","String","rest","doodle","shaders","canvas","pattern","invert","valid","flipH","flipV","flip","reverse","result","cycle","list","separator","symbol","item","shift","mirror","Mirror","code","fromCharCode","once","raw","rules","cut","substring","indexOf","lastIndexOf","endsWith","doodles","decodeURIComponent","atob","e"],"sources":["/Users/mariaeduardatc/Documents/GitHub/website/node_modules/css-doodle/src/function.js"],"sourcesContent":["import { create_svg_url, normalize_svg } from './utils/svg.js';\nimport { generate_svg } from './generator/svg.js';\n\nimport { cell_id, is_letter, is_nil, is_empty, add_alias, unique_id, lerp } from './utils/index.js';\nimport { lazy, clamp, sequence, get_value } from './utils/index.js';\nimport { by_unit, by_charcode } from './utils/transform.js';\nimport { last } from './utils/list.js';\n\nimport calc from './calc.js';\nimport { memo } from './utils/memo.js';\nimport { expand } from './utils/expand.js';\nimport Stack from './utils/stack.js';\nimport Noise from './utils/noise.js';\nimport get_named_arguments from './utils/get-named-arguments.js';\n\nimport { shapes, create_shape_points } from './generator/shapes.js';\nimport parse_value_group from './parser/parse-value-group.js';\nimport parse_shape_commands from './parser/parse-shape-commands.js';\nimport parse_svg from './parser/parse-svg.js';\nimport parse_svg_path from './parser/parse-svg-path.js';\nimport parse_compound_value from './parser/parse-compound-value.js';\n\nimport * as Uniforms from './uniforms.js';\n\nfunction make_sequence(c) {\n  return lazy((_, n, ...actions) => {\n    if (!actions || !n) return '';\n    let count = get_value(n());\n    let evaluated = count;\n    if (/\\D/.test(count) && !/\\d+[x-]\\d+/.test(count)) {\n      evaluated = calc(count);\n      if (evaluated === 0) {\n        evaluated = count;\n      }\n    }\n    let signature = Math.random();\n    return sequence(\n      evaluated,\n      (...args) => {\n        return actions.map(action => {\n          return get_value(action(...args, signature))\n        }).join(',');\n      }\n    ).join(c);\n  });\n}\n\nfunction push_stack(context, name, value) {\n  if (!context[name]) context[name] = new Stack(1024);\n  context[name].push(value);\n  return value;\n}\n\nfunction flip_value(num) {\n  return -1 * num;\n}\n\nfunction map2d(value, min, max, amp = 1) {\n  let dimension = 2;\n  let v = Math.sqrt(dimension / 4) * amp;\n  let [ma, mb] = [-v, v];\n  return lerp((value - ma) / (mb - ma), min * amp, max * amp);\n}\n\nfunction compute(op, a, b) {\n  switch (op) {\n    case '+': return a + b;\n    case '-': return a - b;\n    case '*': return a * b;\n    case '/': return a / b;\n    case '%': return a % b;\n    default: return 0;\n  }\n}\n\nfunction calc_with(base) {\n  return v => {\n    if (is_empty(v) || is_empty(base)) {\n      return base;\n    }\n    if (/^[+*-\\/%][\\-.\\d\\s]/.test(v)) {\n      let op = v[0];\n      let { unit = '', value } = parse_compound_value(v.substr(1).trim() || 0);\n      return compute(op, base, value) + unit;\n    }\n    else if (/[+*-\\/%]$/.test(v)) {\n      let op = v.substr(-1);\n      let { unit = '', value } = parse_compound_value(v.substr(0, v.length - 1).trim() || 0);\n      return compute(op, value, base) + unit;\n    } else {\n      let { unit = '', value } = parse_compound_value(v || 0);\n      return (base + value) + unit;\n    }\n  }\n}\n\nconst Expose = add_alias({\n\n  i({ count }) {\n    return calc_with(count);\n  },\n\n  y({ y }) {\n    return calc_with(y);\n  },\n\n  x({ x }) {\n    return calc_with(x);\n  },\n\n  z({ z }) {\n    return calc_with(z);\n  },\n\n  I({ grid }) {\n    return calc_with(grid.count);\n  },\n\n  Y({ grid }) {\n    return calc_with(grid.y);\n  },\n\n  X({ grid }) {\n    return calc_with(grid.x);\n  },\n\n  Z({ grid }) {\n    return calc_with(grid.z);\n  },\n\n  id({ x, y, z }) {\n    return _ => cell_id(x, y, z);\n  },\n\n  dx({ x, grid }) {\n    return n => {\n      n = Number(n) || 0;\n      return x - .5 - n - grid.x / 2;\n    }\n  },\n\n  dy({ y, grid }) {\n    return n => {\n      n = Number(n) || 0;\n      return y - .5 - n - grid.y / 2;\n    }\n  },\n\n  n({ extra }) {\n    let lastExtra = last(extra);\n    return lastExtra ? calc_with(lastExtra[0]) : '@n';\n  },\n\n  nx({ extra }) {\n    let lastExtra = last(extra);\n    return lastExtra ? calc_with(lastExtra[1]) : '@nx';\n  },\n\n  ny({ extra }) {\n    let lastExtra = last(extra);\n    return lastExtra ? calc_with(lastExtra[2]) : '@ny';\n  },\n\n  N({ extra }) {\n    let lastExtra = last(extra);\n    return lastExtra ? calc_with(lastExtra[3]) : '@N';\n  },\n\n  m: make_sequence(','),\n\n  M: make_sequence(' '),\n\n  µ: make_sequence(''),\n\n  p({ context, pick }) {\n    return expand((...args) => {\n      if (!args.length) {\n        args = context.last_pick_args || [];\n      }\n      let picked = pick(args);\n      context.last_pick_args = args;\n      return push_stack(context, 'last_pick', picked);\n    });\n  },\n\n  P({ context, pick, position }) {\n    let counter = 'P-counter' + position;\n    return expand((...args) => {\n      let normal = true;\n      if (!args.length) {\n        args = context.last_pick_args || [];\n        normal = false;\n      }\n      let stack = context.last_pick;\n      let last = stack ? stack.last(1) : '';\n      if (normal) {\n        if (!context[counter]) {\n          context[counter] = {};\n        }\n        last = context[counter].last_pick;\n      }\n      if (args.length > 1) {\n        let i = args.findIndex(n => n === last);\n        if (i !== -1) {\n          args.splice(i, 1);\n        }\n      }\n      let picked = pick(args);\n      context.last_pick_args = args;\n      if (normal) {\n        context[counter].last_pick = picked;\n      }\n      return push_stack(context, 'last_pick', picked);\n    });\n  },\n\n  pl({ context, extra, position }) {\n    let lastExtra = last(extra);\n    let sig = lastExtra ? last(lastExtra) : '';\n    let counter = 'pl-counter' + position + sig;\n    return expand((...args) => {\n      if (!context[counter]) context[counter] = 0;\n      context[counter] += 1;\n      let max = args.length;\n      let idx = lastExtra && lastExtra[6];\n      if (is_nil(idx)) idx = context[counter];\n      let pos = (idx - 1) % max;\n      let value = args[pos];\n      return push_stack(context, 'last_pick', value);\n    });\n  },\n\n  pr({ context, extra, position }) {\n    let lastExtra = last(extra);\n    let sig = lastExtra ? last(lastExtra) : '';\n    let counter = 'pr-counter' + position + sig;\n    return expand((...args) => {\n      if (!context[counter]) context[counter] = 0;\n      context[counter] += 1;\n      let max = args.length;\n      let idx = lastExtra && lastExtra[6];\n      if (is_nil(idx)) idx = context[counter];\n      let pos = (idx - 1) % max;\n      let value = args[max - pos - 1];\n      return push_stack(context, 'last_pick', value);\n    });\n  },\n\n  pd({ context, extra, position, shuffle }) {\n    let lastExtra = last(extra);\n    let sig = lastExtra ? last(lastExtra) : '';\n    let counter = 'pd-counter' + position  + sig;\n    let values = 'pd-values' + position + sig;;\n    return expand((...args) => {\n      if (!context[counter]) context[counter] = 0;\n      context[counter] += 1;\n      if (!context[values]) {\n        context[values] = shuffle(args || []);\n      }\n      let max = args.length;\n      let idx = lastExtra && lastExtra[6];\n      if (is_nil(idx)) idx = context[counter];\n      let pos = (idx - 1) % max;\n      let value = context[values][pos];\n      return push_stack(context, 'last_pick', value);\n    });\n  },\n\n  lp({ context }) {\n    return (n = 1) => {\n      let stack = context.last_pick;\n      return stack ? stack.last(n) : '';\n    };\n  },\n\n  r({ context, rand }) {\n    return (...args) => {\n      let transform = args.every(is_letter)\n        ? by_charcode\n        : by_unit;\n      let value = transform(rand)(...args);\n      return push_stack(context, 'last_rand', value);\n    };\n  },\n\n  rn({ x, y, context, position, grid, extra, random }) {\n    let counter = 'noise-2d' + position;\n    let counterX = counter + 'offset-x';\n    let counterY = counter + 'offset-y';\n    let [ni, nx, ny, nm, NX, NY] = last(extra) || [];\n    let isSeqContext = (ni && nm);\n    return (...args) => {\n      let {from = 0, to = from, frequency = 1, scale = 1, octave = 1} = get_named_arguments(args, [\n        'from', 'to', 'frequency', 'scale', 'octave'\n      ]);\n\n      frequency = clamp(frequency, 0, Infinity);\n      scale = clamp(scale, 0, Infinity);\n      octave = clamp(octave, 1, 100);\n\n      if (args.length == 1) [from, to] = [0, from];\n      if (!context[counter]) context[counter] = new Noise();\n      if (!context[counterX]) context[counterX] = random();\n      if (!context[counterY]) context[counterY] = random();\n\n      let transform = (is_letter(from) && is_letter(to)) ? by_charcode : by_unit;\n      let noise2d = context[counter];\n      let offsetX = context[counterX];\n      let offsetY = context[counterY];\n      let _x = (isSeqContext ? ((nx - 1) / NX) : ((x - 1) / grid.x)) + offsetX;\n      let _y = (isSeqContext ? ((ny - 1) / NY) : ((y - 1) / grid.y)) + offsetY;\n\n      // 1-dimentional\n      if (NX <= 1 || grid.x <= 1) _x = 0;\n      if (NY <= 1 || grid.y <= 1) _y = 0;\n\n      // 1x1\n      if (_x == 0 && _y == 0) {\n        _x = offsetX;\n        _y = offsetY;\n      }\n\n      let t = noise2d.noise(_x * frequency, _y * frequency, 0) * scale;\n\n      for (let i = 1; i < octave; ++i) {\n        let i2 = i * 2;\n        t += noise2d.noise(_x * frequency * i2, _y * frequency * i2, 0) * (scale / i2);\n      }\n      let fn = transform((from, to) => map2d(t, from, to, scale));\n      return push_stack(context, 'last_rand', fn(from, to));\n    };\n  },\n\n  lr({ context }) {\n    return (n = 1) => {\n      let stack = context.last_rand;\n      return stack ? stack.last(n) : '';\n    };\n  },\n\n  stripe() {\n    return (...input) => {\n      let colors = input.map(get_value);\n      let max = colors.length;\n      let default_count = 0;\n      let custom_sizes = [];\n      let prev;\n      if (!max) {\n        return '';\n      }\n      colors.forEach(step => {\n        let [_, size] = parse_value_group(step);\n        if (size !== undefined) custom_sizes.push(size);\n        else default_count += 1;\n      });\n      let default_size = custom_sizes.length\n        ? `(100% - ${custom_sizes.join(' - ')}) / ${default_count}`\n        : `100% / ${max}`\n      return colors.map((step, i) => {\n        if (custom_sizes.length) {\n          let [color, size] = parse_value_group(step);\n          let prefix = prev ? (prev + ' + ') : '';\n          prev = prefix + (size !== undefined ? size : default_size);\n          return `${color} 0 calc(${ prev })`\n        }\n        return `${step} 0 ${100 / max * (i + 1)}%`\n      })\n      .join(',');\n    }\n  },\n\n  calc() {\n    return (value, context) => {\n      return calc(get_value(value), context);\n    }\n  },\n\n  hex() {\n    return value => parseInt(get_value(value)).toString(16);\n  },\n\n  svg: lazy((_, ...args) => {\n    let value = args.map(input => get_value(input())).join(',');\n    if (!value.startsWith('<')) {\n      let parsed = parse_svg(value);\n      value = generate_svg(parsed);\n    }\n    let svg = normalize_svg(value);\n    return create_svg_url(svg);\n  }),\n\n  'svg-filter': lazy((upstream, ...args) => {\n    let values = args.map(input => get_value(input()));\n    let value = values.join(',');\n    let id = unique_id('filter-');\n    // shorthand\n    if (values.every(n => /^[\\-\\d.]/.test(n) || (/^(\\w+)/.test(n) && !/[{}<>]/.test(n)))) {\n      let { frequency, scale, octave, seed = upstream.seed, blur, erode, dilate } = get_named_arguments(values, [\n        'frequency', 'scale', 'octave', 'seed', 'blur', 'erode', 'dilate'\n      ]);\n      value = `\n        x: -20%;\n        y: -20%;\n        width: 140%;\n        height: 140%;\n      `;\n      if (!is_nil(dilate)) {\n        value += `\n          feMorphology {\n            operator: dilate;\n            radius: ${dilate};\n          }\n        `\n      }\n      if (!is_nil(erode)) {\n        value += `\n          feMorphology {\n            operator: erode;\n            radius: ${erode};\n          }\n        `\n      }\n      if (!is_nil(blur)) {\n        value += `\n          feGaussianBlur {\n            stdDeviation: ${blur};\n          }\n        `\n      }\n      if (!is_nil(frequency)) {\n        let [bx, by = bx] = parse_value_group(frequency);\n        octave = octave ? `numOctaves: ${octave};` : '';\n        value += `\n          feTurbulence {\n            type: fractalNoise;\n            baseFrequency: ${bx} ${by};\n            seed: ${seed};\n            ${octave}\n          }\n        `;\n        if (scale) {\n          value += `\n            feDisplacementMap {\n              in: SourceGraphic;\n              scale: ${scale};\n            }\n          `;\n        }\n      }\n    }\n    // new svg syntax\n    if (!value.startsWith('<')) {\n      let parsed = parse_svg(value, {\n        type: 'block',\n        name: 'filter'\n      });\n      value = generate_svg(parsed);\n    }\n    let svg = normalize_svg(value).replace(\n      /<filter([\\s>])/,\n      `<filter id=\"${ id }\"$1`\n    );\n    return create_svg_url(svg, id);\n  }),\n\n  'svg-pattern': lazy((_, ...args) => {\n    let value = args.map(input => get_value(input())).join(',');\n    let parsed = parse_svg(`\n      viewBox: 0 0 1 1;\n      preserveAspectRatio: xMidYMid slice;\n      rect {\n        width, height: 100%;\n        fill: defs pattern { ${ value } }\n      }\n    `);\n    let svg = generate_svg(parsed);\n    return create_svg_url(svg);\n  }),\n\n  'svg-polygon': lazy((_, ...args) => {\n    let value = args.map(input => get_value(input())).join(',');\n    let config = parse_shape_commands(value);\n\n    delete config.frame;\n    config['unit'] = 'none';\n    config['stroke-width'] ??= .01;\n    config['stroke'] ??= 'currentColor';\n    config['fill'] ??= 'none';\n\n    let points = `points: ${create_shape_points(config, {min: 3, max: 65536})};`;\n    let props = '';\n    for (let name of Object.keys(config)) {\n      if (/^(stroke|fill|clip|marker|mask|animate|draw)/.test(name)) {\n        props += `${name}: ${config[name]};`\n      }\n    };\n    let parsed = parse_svg(`\n      viewBox: -1 -1 2 2 p ${Number(config['stroke-width'])/2};\n      polygon {\n        ${props} ${points}\n      }\n    `);\n    return create_svg_url(generate_svg(parsed));\n  }),\n\n  var() {\n    return value => `var(${ get_value(value) })`;\n  },\n\n  ut() {\n    return value => `var(--${ Uniforms.uniform_time.name })`;\n  },\n\n  uw() {\n    return value => `var(--${ Uniforms.uniform_width.name })`;\n  },\n\n  uh() {\n    return value => `var(--${ Uniforms.uniform_height.name })`;\n  },\n\n  ux() {\n    return value => `var(--${ Uniforms.uniform_mousex.name })`;\n  },\n\n  uy() {\n    return value => `var(--${ Uniforms.uniform_mousey.name })`;\n  },\n\n  plot({ count, context, extra, position, grid }) {\n    let key = 'offset-points' + position;\n    let lastExtra = last(extra);\n    return commands => {\n      let [idx = count, _, __, max = grid.count] = lastExtra || [];\n      if (!context[key]) {\n        let config = parse_shape_commands(commands);\n        delete config['fill'];\n        delete config['fill-rule'];\n        delete config['frame'];\n        config.points = max;\n        context[key] = create_shape_points(config, {min: 1, max: 65536});\n      }\n      return context[key][idx - 1];\n    };\n  },\n\n  Plot({ count, context, extra, position, grid }) {\n    let key = 'Offset-points' + position;\n    let lastExtra = last(extra);\n    return commands => {\n      let [idx = count, _, __, max = grid.count] = lastExtra || [];\n      if (!context[key]) {\n        let config = parse_shape_commands(commands);\n        delete config['fill'];\n        delete config['fill-rule'];\n        delete config['frame'];\n        config.points = max;\n        config.unit = config.unit || 'none';\n        context[key] = create_shape_points(config, {min: 1, max: 65536});\n      }\n      return context[key][idx - 1];\n    };\n  },\n\n  shape() {\n    return memo('shape-function', (type = '', ...args) => {\n      type = String(type).trim();\n      let points = [];\n      if (type.length) {\n        if (typeof shapes[type] === 'function') {\n          points = shapes[type](args);\n        } else {\n          let commands = type;\n          let rest = args.join(',');\n          if (rest.length) {\n            commands = type + ',' + rest;\n          }\n          let config = parse_shape_commands(commands);\n          points = create_shape_points(config, {min: 3, max: 3600});\n        }\n      }\n      return `polygon(${points.join(',')})`;\n    });\n  },\n\n  doodle() {\n    return value => value;\n  },\n\n  shaders() {\n    return value => value;\n  },\n\n  canvas() {\n    return value => value;\n  },\n\n  pattern() {\n    return value => value;\n  },\n\n  invert() {\n    return commands => {\n      let parsed = parse_svg_path(commands);\n      if (!parsed.valid) return commands;\n      return parsed.commands.map(({ name, value }) => {\n        switch (name) {\n          case 'v': return 'h' + value.join(' ');\n          case 'V': return 'H' + value.join(' ');\n          case 'h': return 'v' + value.join(' ');\n          case 'H': return 'V' + value.join(' ');\n          default:  return name + value.join(' ');\n        }\n      }).join(' ');\n    };\n  },\n\n  flipH() {\n    return commands => {\n      let parsed = parse_svg_path(commands);\n      if (!parsed.valid) return commands;\n      return parsed.commands.map(({ name, value }) => {\n        switch (name) {\n          case 'h':\n          case 'H': return name + value.map(flip_value).join(' ');\n          default:  return name + value.join(' ');\n        }\n      }).join(' ');\n    };\n  },\n\n  flipV() {\n    return commands => {\n      let parsed = parse_svg_path(commands);\n      if (!parsed.valid) return commands;\n      return parsed.commands.map(({ name, value }) => {\n        switch (name) {\n          case 'v':\n          case 'V': return name + value.map(flip_value).join(' ');\n          default:  return name + value.join(' ');\n        }\n      }).join(' ');\n    };\n  },\n\n  flip(...args) {\n    let flipH = Expose.flipH(...args);\n    let flipV = Expose.flipV(...args);\n    return commands => {\n      return flipV(flipH(commands));\n    }\n  },\n\n  reverse() {\n    return (...args) => {\n      let commands = args.map(get_value);\n      let parsed = parse_svg_path(commands.join(','));\n      if (parsed.valid) {\n        let result = [];\n        for (let i = parsed.commands.length - 1; i >= 0; --i) {\n          let { name, value } = parsed.commands[i];\n          result.push(name + value.join(' '));\n        }\n        return result.join(' ');\n      }\n      return commands.reverse();\n    }\n  },\n\n  cycle() {\n    return (...args) => {\n      args = args.map(n => '(' + n + ')');\n      let list = [];\n      let separator;\n      if (args.length == 1) {\n        separator = ' ';;\n        list = parse_value_group(args[0], { symbol: separator });\n      } else {\n        separator = ',';\n        list = parse_value_group(args.map(get_value).join(separator), { symbol: separator});\n      }\n      list = list.map(n => n.replace(/^\\(|\\)$/g,''));\n      let size = list.length - 1;\n      let result = [list.join(separator)];\n      // Just ignore the performance\n      for (let i = 0; i < size; ++i) {\n        let item = list.shift();\n        list.push(item);\n        result.push(list.join(separator));\n      }\n      return result;\n    }\n  },\n\n  mirror() {\n    return (...args) => {\n      for (let i = args.length - 1; i >= 0; --i) {\n        args.push(args[i]);\n      }\n      return args;\n    }\n  },\n\n  Mirror() {\n    return (...args) => {\n      for (let i = args.length - 2; i >= 0; --i) {\n        args.push(args[i]);\n      }\n      return args;\n    }\n  },\n\n  code() {\n    return (...args) => {\n      return args.map(code => String.fromCharCode(code));\n    }\n  },\n\n  once({ context, extra, position }) {\n    let counter = 'once-counter' + position;\n    return (...args) => {\n      if (is_nil(context[counter])) {\n        context[counter] = args;\n      }\n      return context[counter];\n    }\n  },\n\n  raw({ rules }) {\n    return (raw = '') => {\n      try {\n        let cut = raw.substring(raw.indexOf(',') + 1, raw.lastIndexOf('\")'));\n        if (raw.startsWith('${doodle') && raw.endsWith('}')) {\n          let key = raw.substring(2, raw.length - 1);\n          let doodles = rules.doodles;\n          if (doodles && doodles[key]) {\n            return `<css-doodle>${doodles[key].doodle}</css-doodle>`\n          }\n        }\n        if (raw.startsWith('url(\"data:image/svg+xml;utf8')) {\n          return decodeURIComponent(cut);\n        }\n        /* future forms */\n        if (raw.startsWith('url(\"data:image/svg+xml;base64')) {\n          return atob(cut);\n        }\n        if (raw.startsWith('url(\"data:image/png;base64')) {\n          return `<img src=\"${raw}\" alt=\"\" />`;\n        }\n      } catch (e) {\n        /* ignore */\n      }\n      return raw;\n    }\n  }\n\n}, {\n\n  'index': 'i',\n  'col': 'x',\n  'row': 'y',\n  'depth': 'z',\n  'rand': 'r',\n  'pick': 'p',\n  'pn':   'pl',\n  'pnr':  'pr',\n\n  // error prone\n  'stripes': 'stripe',\n  'strip':   'stripe',\n  'patern':  'pattern',\n  'flipv': 'flipV',\n  'fliph': 'flipH',\n\n  // legacy names, keep them before 1.0\n  't': 'ut',\n  'filter': 'svg-filter',\n  'last-rand': 'lr',\n  'last-pick': 'lp',\n  'multiple': 'm',\n  'multi': 'm',\n  'rep': 'µ',\n  'repeat': 'µ',\n  'ms': 'M',\n  's':  'I',\n  'size': 'I',\n  'sx': 'X',\n  'size-x': 'X',\n  'size-col': 'X',\n  'max-col': 'X',\n  'sy': 'Y',\n  'size-y': 'Y',\n  'size-row': 'Y',\n  'max-row': 'Y',\n  'sz': 'Z',\n  'size-z': 'Z',\n  'size-depth': 'Z',\n  'Svg': 'svg',\n  'pick-by-turn': 'pl',\n  'pick-n': 'pl',\n  'pick-d': 'pd',\n  'offset': 'plot',\n  'Offset': 'Plot',\n  'point': 'plot',\n  'Point': 'Plot',\n  'paint': 'canvas',\n  'unicode': 'code'\n});\n\nexport default Expose;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}