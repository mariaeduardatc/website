{"ast":null,"code":"/**\n * This is totally rewrite for the old parser module\n * I'll improve and replace them little by little.\n */\n\nconst symbols = [':', ';', ',', '(', ')', '[', ']', '{', '}', 'π', '±', '+', '-', '*', '/', '%', '\"', \"'\", '`', '@', '=', '^'];\nconst is = {\n  escape: c => c == '\\\\',\n  space: c => /[\\r\\n\\t\\s]/.test(c),\n  digit: c => /^[0-9]$/.test(c),\n  sign: c => /^[+-]$/.test(c),\n  dot: c => c == '.',\n  quote: c => /^[\"'`]$/.test(c),\n  symbol: c => symbols.includes(c),\n  hexNum: c => /^[0-9a-f]$/i.test(c),\n  hex: (a, b, c) => a == '0' && is.letter(b, 'x') && is.hexNum(c),\n  expWithSign: (a, b, c) => is.letter(a, 'e') && is.sign(b) && is.digit(c),\n  exp: (a, b) => is.letter(a, 'e') && is.digit(b),\n  dots: (a, b) => is.dot(a) && is.dot(b),\n  letter: (a, b) => String(a).toLowerCase() == String(b).toLowerCase(),\n  comment: (a, b) => a == '/' && b == '*',\n  inlineComment: (a, b) => a == '/' && b === '/',\n  selfClosedTag: (a, b) => a == '/' && b == '>',\n  closedTag: (a, b) => a == '<' && b == '/'\n};\nclass Token {\n  constructor(_ref) {\n    let {\n      type,\n      value,\n      pos,\n      status\n    } = _ref;\n    this.type = type;\n    this.value = value;\n    this.pos = pos;\n    if (status) {\n      this.status = status;\n    }\n  }\n  isSymbol() {\n    let isSymbol = this.type == 'Symbol';\n    for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n      values[_key] = arguments[_key];\n    }\n    if (!values.length) return isSymbol;\n    return values.some(c => c === this.value);\n  }\n  isSpace() {\n    return this.type == 'Space';\n  }\n  isNumber() {\n    return this.type == 'Number';\n  }\n  isWord() {\n    return this.type == 'Word';\n  }\n}\nfunction iterator(input) {\n  let pointer = -1;\n  let max = input.length;\n  let col = -1,\n    row = 0;\n  return {\n    curr() {\n      let n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      return input[pointer + n];\n    },\n    next() {\n      let n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      let next = input[pointer += n];\n      if (next === '\\n') row++, col = 0;else col += n;\n      return next;\n    },\n    end() {\n      return pointer >= max;\n    },\n    get() {\n      return {\n        prev: input[pointer - 1],\n        curr: input[pointer + 0],\n        next: input[pointer + 1],\n        next2: input[pointer + 2],\n        next3: input[pointer + 3],\n        pos: [col, row]\n      };\n    }\n  };\n}\nfunction skipComments(iter) {\n  while (iter.next()) {\n    let {\n      curr,\n      prev\n    } = iter.get();\n    if (is.comment(curr, prev)) break;\n  }\n}\nfunction skipInlineComments(iter) {\n  while (iter.next()) {\n    if (iter.curr() === '\\n') break;\n  }\n}\nfunction ignoreSpacingSymbol(value) {\n  return [':', ';', ',', '{', '}', '(', ')', '[', ']'].includes(value);\n}\nfunction readWord(iter) {\n  let temp = '';\n  while (!iter.end()) {\n    let {\n      curr,\n      next\n    } = iter.get();\n    temp += curr;\n    let isBreak = is.symbol(next) || is.space(next) || is.digit(next);\n    if (temp.length && isBreak) {\n      if (!is.closedTag(curr, next)) break;\n    }\n    iter.next();\n  }\n  return temp.trim();\n}\nfunction readSpaces(iter) {\n  let temp = '';\n  while (!iter.end()) {\n    let {\n      curr,\n      next\n    } = iter.get();\n    temp += curr;\n    if (!is.space(next)) break;\n    iter.next();\n  }\n  return temp;\n}\nfunction readNumber(iter) {\n  let temp = '';\n  let hasDot = false;\n  while (!iter.end()) {\n    let {\n      curr,\n      next,\n      next2,\n      next3\n    } = iter.get();\n    temp += curr;\n    if (hasDot && is.dot(next)) break;\n    if (is.dot(curr)) hasDot = true;\n    if (is.dots(next, next2)) break;\n    if (is.expWithSign(next, next2, next3)) {\n      temp += iter.next() + iter.next();\n    } else if (is.exp(next, next2)) {\n      temp += iter.next();\n    } else if (!is.digit(next) && !is.dot(next)) {\n      break;\n    }\n    iter.next();\n  }\n  return temp;\n}\nfunction readHexNumber(iter) {\n  let temp = '0x';\n  iter.next(2);\n  while (!iter.end()) {\n    let {\n      curr,\n      next\n    } = iter.get();\n    temp += curr;\n    if (!is.hexNum(next)) break;\n    iter.next();\n  }\n  return temp;\n}\nfunction last(array) {\n  return array[array.length - 1];\n}\nfunction scan(source) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let iter = iterator(String(source).trim());\n  let tokens = [];\n  let quoteStack = [];\n  while (iter.next()) {\n    let {\n      prev,\n      curr,\n      next,\n      next2,\n      pos\n    } = iter.get();\n    if (is.comment(curr, next)) {\n      skipComments(iter);\n    } else if (options.ignoreInlineComment && is.inlineComment(curr, next)) {\n      skipInlineComments(iter);\n    } else if (is.hex(curr, next, next2)) {\n      let num = readHexNumber(iter);\n      tokens.push(new Token({\n        type: 'Number',\n        value: num,\n        pos\n      }));\n    } else if (is.digit(curr) || is.digit(next) && is.dot(curr) && !is.dots(prev, curr)) {\n      let num = readNumber(iter);\n      tokens.push(new Token({\n        type: 'Number',\n        value: num,\n        pos\n      }));\n    } else if (is.symbol(curr) && !is.selfClosedTag(curr, next)) {\n      let lastToken = last(tokens);\n      // negative\n      let isNextDigit = is.digit(next) || is.dot(next) && is.digit(next2);\n      if (curr === '-' && isNextDigit && (!lastToken || !lastToken.isNumber())) {\n        let num = readNumber(iter);\n        tokens.push(new Token({\n          type: 'Number',\n          value: num,\n          pos\n        }));\n        continue;\n      }\n      let token = {\n        type: 'Symbol',\n        value: curr,\n        pos\n      };\n      // Escaped symbols\n      if (quoteStack.length && is.escape(lastToken.value)) {\n        tokens.pop();\n        let word = readWord(iter);\n        if (word.length) {\n          tokens.push(new Token({\n            type: 'Word',\n            value: word,\n            pos\n          }));\n        }\n      } else {\n        if (is.quote(curr)) {\n          let lastQuote = last(quoteStack);\n          if (lastQuote == curr) {\n            quoteStack.pop();\n            token.status = 'close';\n          } else {\n            quoteStack.push(curr);\n            token.status = 'open';\n          }\n        }\n        tokens.push(new Token(token));\n      }\n    } else if (is.space(curr)) {\n      let spaces = readSpaces(iter);\n      let lastToken = last(tokens);\n      let {\n        next\n      } = iter.get();\n      // Reduce unnecessary spaces\n      if (!quoteStack.length && lastToken) {\n        let prev = lastToken.value;\n        let ignoreLeft = ignoreSpacingSymbol(prev) && prev !== ')';\n        let ignoreRight = ignoreSpacingSymbol(next) && next !== '(';\n        if (ignoreLeft || ignoreRight) {\n          continue;\n        } else {\n          spaces = options.preserveLineBreak ? curr : ' ';\n        }\n      }\n      if (tokens.length && next && next.trim()) {\n        tokens.push(new Token({\n          type: 'Space',\n          value: spaces,\n          pos\n        }));\n      }\n    } else {\n      let word = readWord(iter);\n      if (word.length) {\n        tokens.push(new Token({\n          type: 'Word',\n          value: word,\n          pos\n        }));\n      }\n    }\n  }\n\n  // Remove last space token\n  let lastToken = last(tokens);\n  if (lastToken && lastToken.isSpace()) {\n    tokens.length = tokens.length - 1;\n  }\n  return tokens;\n}\nexport { symbols, is, iterator, scan, Token };","map":{"version":3,"names":["symbols","is","escape","c","space","test","digit","sign","dot","quote","symbol","includes","hexNum","hex","a","b","letter","expWithSign","exp","dots","String","toLowerCase","comment","inlineComment","selfClosedTag","closedTag","Token","constructor","type","value","pos","status","isSymbol","values","length","some","isSpace","isNumber","isWord","iterator","input","pointer","max","col","row","curr","n","next","end","get","prev","next2","next3","skipComments","iter","skipInlineComments","ignoreSpacingSymbol","readWord","temp","isBreak","trim","readSpaces","readNumber","hasDot","readHexNumber","last","array","scan","source","options","tokens","quoteStack","ignoreInlineComment","num","push","lastToken","isNextDigit","token","pop","word","lastQuote","spaces","ignoreLeft","ignoreRight","preserveLineBreak"],"sources":["/Users/mariaeduardatc/Documents/GitHub/website/node_modules/css-doodle/src/parser/tokenizer.js"],"sourcesContent":["/**\n * This is totally rewrite for the old parser module\n * I'll improve and replace them little by little.\n */\n\nconst symbols = [\n  ':', ';', ',', '(', ')', '[', ']',\n  '{', '}', 'π', '±', '+', '-', '*',\n  '/', '%', '\"', \"'\", '`', '@', '=',\n  '^',\n];\n\nconst is = {\n  escape: c => c == '\\\\',\n  space:  c => /[\\r\\n\\t\\s]/.test(c),\n  digit:  c => /^[0-9]$/.test(c),\n  sign:   c => /^[+-]$/.test(c),\n  dot:    c => c == '.',\n  quote:  c => /^[\"'`]$/.test(c),\n  symbol: c => symbols.includes(c),\n  hexNum: c => /^[0-9a-f]$/i.test(c),\n  hex:           (a, b, c) => a == '0' && is.letter(b, 'x') && is.hexNum(c),\n  expWithSign:   (a, b, c) => is.letter(a, 'e') && is.sign(b) && is.digit(c),\n  exp:           (a, b) => is.letter(a, 'e') && is.digit(b),\n  dots:          (a, b) => is.dot(a) && is.dot(b),\n  letter:        (a, b) => String(a).toLowerCase() == String(b).toLowerCase(),\n  comment:       (a, b) => a == '/' && b == '*',\n  inlineComment: (a, b) => a == '/' && b === '/',\n  selfClosedTag: (a, b) => a == '/' && b == '>',\n  closedTag:     (a, b) => a == '<' && b == '/',\n}\n\nclass Token {\n  constructor({ type, value, pos, status }) {\n    this.type = type;\n    this.value = value;\n    this.pos = pos;\n    if (status) {\n      this.status = status;\n    }\n  }\n  isSymbol(...values) {\n    let isSymbol = this.type == 'Symbol';\n    if (!values.length) return isSymbol;\n    return values.some(c => c === this.value);\n  }\n  isSpace() {\n    return this.type == 'Space';\n  }\n  isNumber() {\n    return this.type == 'Number';\n  }\n  isWord() {\n    return this.type == 'Word';\n  }\n}\n\nfunction iterator(input) {\n  let pointer = -1;\n  let max = input.length;\n  let col = -1, row = 0;\n  return {\n    curr(n = 0) {\n      return input[pointer + n];\n    },\n    next(n = 1) {\n      let next = input[pointer += n];\n      if (next === '\\n') row++, col = 0;\n      else col += n;\n      return next;\n    },\n    end() {\n      return pointer >= max;\n    },\n    get() {\n      return {\n        prev:  input[pointer - 1],\n        curr:  input[pointer + 0],\n        next:  input[pointer + 1],\n        next2: input[pointer + 2],\n        next3: input[pointer + 3],\n        pos:   [col, row],\n      }\n    }\n  }\n}\n\nfunction skipComments(iter) {\n  while (iter.next()) {\n    let { curr, prev } = iter.get();\n    if (is.comment(curr, prev)) break;\n  }\n}\n\nfunction skipInlineComments(iter) {\n  while (iter.next()) {\n    if (iter.curr() === '\\n') break;\n  }\n}\n\nfunction ignoreSpacingSymbol(value) {\n   return [':', ';', ',', '{', '}', '(', ')', '[', ']'].includes(value);\n}\n\nfunction readWord(iter) {\n  let temp = '';\n  while (!iter.end()) {\n    let { curr, next } = iter.get();\n    temp += curr;\n    let isBreak = is.symbol(next) || is.space(next) || is.digit(next);\n    if (temp.length && isBreak) {\n      if (!is.closedTag(curr, next)) break;\n    }\n    iter.next();\n  }\n  return temp.trim();\n}\n\nfunction readSpaces(iter) {\n  let temp = '';\n  while (!iter.end()) {\n    let { curr, next } = iter.get();\n    temp += curr;\n    if (!is.space(next)) break;\n    iter.next();\n  }\n  return temp;\n}\n\nfunction readNumber(iter) {\n  let temp = '';\n  let hasDot = false;\n  while (!iter.end()) {\n    let { curr, next, next2, next3 } = iter.get();\n    temp += curr;\n    if (hasDot && is.dot(next)) break;\n    if (is.dot(curr)) hasDot = true;\n    if (is.dots(next, next2)) break;\n    if (is.expWithSign(next, next2, next3)) {\n      temp += iter.next() + iter.next();\n    }\n    else if (is.exp(next, next2)) {\n      temp += iter.next();\n    }\n    else if (!is.digit(next) && !is.dot(next)) {\n      break;\n    }\n    iter.next();\n  }\n  return temp;\n}\n\nfunction readHexNumber(iter) {\n  let temp = '0x';\n  iter.next(2);\n  while (!iter.end()) {\n    let { curr, next } = iter.get();\n    temp += curr;\n    if (!is.hexNum(next)) break;\n    iter.next();\n  }\n  return temp;\n}\n\nfunction last(array) {\n  return array[array.length - 1];\n}\n\nfunction scan(source, options = {}) {\n  let iter = iterator(String(source).trim());\n  let tokens = [];\n  let quoteStack = [];\n\n  while (iter.next()) {\n    let { prev, curr, next, next2, pos } = iter.get();\n    if (is.comment(curr, next)) {\n      skipComments(iter);\n    }\n    else if (options.ignoreInlineComment && is.inlineComment(curr, next)) {\n      skipInlineComments(iter);\n    }\n    else if (is.hex(curr, next, next2)) {\n      let num = readHexNumber(iter);\n      tokens.push(new Token({\n        type: 'Number', value: num, pos\n      }));\n    }\n    else if (is.digit(curr) || (\n        is.digit(next) && is.dot(curr) && !is.dots(prev, curr))) {\n      let num = readNumber(iter);\n      tokens.push(new Token({\n        type: 'Number', value: num, pos\n      }));\n    }\n    else if (is.symbol(curr) && !is.selfClosedTag(curr, next)) {\n      let lastToken = last(tokens);\n      // negative\n      let isNextDigit = is.digit(next) || (is.dot(next) && is.digit(next2));\n      if (curr === '-' && isNextDigit && (!lastToken || !lastToken.isNumber())) {\n        let num = readNumber(iter);\n        tokens.push(new Token({\n          type: 'Number', value: num, pos\n        }));\n        continue;\n      }\n\n      let token = {\n        type: 'Symbol', value: curr, pos\n      }\n      // Escaped symbols\n      if (quoteStack.length && is.escape(lastToken.value)) {\n        tokens.pop();\n        let word = readWord(iter);\n        if (word.length) {\n          tokens.push(new Token({\n            type: 'Word', value: word, pos\n          }));\n        }\n      }\n      else {\n        if (is.quote(curr)) {\n          let lastQuote = last(quoteStack);\n          if (lastQuote == curr) {\n            quoteStack.pop();\n            token.status = 'close';\n          } else {\n            quoteStack.push(curr);\n            token.status = 'open';\n          }\n        }\n\n        tokens.push(new Token(token));\n      }\n    }\n    else if (is.space(curr)) {\n      let spaces = readSpaces(iter);\n      let lastToken = last(tokens);\n      let { next } = iter.get();\n      // Reduce unnecessary spaces\n      if (!quoteStack.length && lastToken) {\n        let prev = lastToken.value;\n        let ignoreLeft = (ignoreSpacingSymbol(prev) && prev !== ')');\n        let ignoreRight = (ignoreSpacingSymbol(next) && next !== '(');\n        if (ignoreLeft || ignoreRight)  {\n          continue;\n        } else {\n          spaces = options.preserveLineBreak ? curr : ' ';\n        }\n      }\n      if (tokens.length && (next && next.trim())) {\n        tokens.push(new Token({\n          type: 'Space', value: spaces, pos\n        }));\n      }\n    }\n    else {\n      let word = readWord(iter);\n      if (word.length) {\n        tokens.push(new Token({\n          type: 'Word', value: word, pos\n        }));\n      }\n    }\n  }\n\n  // Remove last space token\n  let lastToken = last(tokens);\n  if (lastToken && lastToken.isSpace()) {\n    tokens.length = tokens.length - 1;\n  }\n  return tokens;\n}\n\nexport {\n  symbols,\n  is,\n  iterator,\n  scan,\n  Token\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}