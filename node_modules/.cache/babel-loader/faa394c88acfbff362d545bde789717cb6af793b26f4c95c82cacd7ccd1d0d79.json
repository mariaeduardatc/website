{"ast":null,"code":"import { scan, iterator } from './tokenizer.js';\nimport parseValueGroup from './parse-value-group.js';\nfunction readStatement(iter, token) {\n  let fragment = [];\n  let inlineBlock;\n  let stackQuote = [];\n  let stackParen = [];\n  while (iter.next()) {\n    let {\n      curr,\n      next\n    } = iter.get();\n    if (curr.isSymbol('(') && !stackQuote.length) {\n      stackParen.push(curr);\n    } else if (curr.isSymbol(')') && !stackQuote.length) {\n      stackParen.pop();\n    }\n    if (curr.isSymbol(\"'\", '\"')) {\n      if (curr.status === 'open') {\n        stackQuote.push(curr);\n      } else {\n        stackQuote.pop();\n      }\n    }\n    let isStatementBreak = !stackQuote.length && !stackParen.length && (!next || curr.isSymbol(';') || next.isSymbol('}'));\n    if (curr.isSymbol(\"'\", '\"')) {\n      if (next && next.isSymbol('}') && !stackQuote.length) {\n        isStatementBreak = true;\n      }\n    }\n    if (!stackParen.length && !stackQuote.length && curr.isSymbol('{')) {\n      let selectors = getSelectors(fragment);\n      if (!selectors.length) {\n        continue;\n      }\n      let tokenName = selectors.pop();\n      let skip = isSkip(...selectors, tokenName);\n      inlineBlock = resolveId(walk(iter, splitTimes(tokenName, {\n        type: 'block',\n        inline: true,\n        name: tokenName,\n        value: []\n      })), skip);\n      while (tokenName = selectors.pop()) {\n        inlineBlock = resolveId(splitTimes(tokenName, {\n          type: 'block',\n          name: tokenName,\n          value: [inlineBlock]\n        }), skip);\n      }\n      break;\n    }\n    fragment.push(curr);\n    if (isStatementBreak) {\n      break;\n    }\n  }\n  if (fragment.length && !inlineBlock) {\n    token._valueTokens = fragment;\n    token.value = joinToken(fragment);\n  } else if (inlineBlock) {\n    token.value = inlineBlock;\n  }\n  if (token.origin) {\n    token.origin.value = token.value;\n  }\n  return token;\n}\nfunction readStyle(iter) {\n  let stack = [];\n  let style = [];\n  while (iter.next()) {\n    let {\n      curr\n    } = iter.get();\n    if (curr.isSymbol('{')) {\n      stack.push(curr.value);\n    } else if (curr.isSymbol('}')) {\n      if (stack.length) {\n        stack.pop();\n      } else {\n        break;\n      }\n    }\n    style.push(curr.value);\n  }\n  return style.join('');\n}\nfunction walk(iter, parentToken) {\n  let rules = [];\n  let fragment = [];\n  let tokenType = parentToken && parentToken.type || '';\n  let stack = [];\n  while (iter.next()) {\n    let {\n      prev,\n      curr,\n      next\n    } = iter.get();\n    if (curr.isSymbol('(')) {\n      stack.push(curr.value);\n    }\n    if (curr.isSymbol(')')) {\n      stack.pop();\n    }\n    let isBlockBreak = !next || curr.isSymbol('}');\n    if (isBlock(tokenType) && isBlockBreak) {\n      if (!next && rules.length && !curr.isSymbol('}')) {\n        let last = rules[rules.length - 1].value;\n        if (typeof last === 'string') {\n          rules[rules.length - 1].value += ';' + curr.value;\n        }\n      }\n      parentToken.value = rules;\n      break;\n    } else if (curr.isSymbol('{')) {\n      let selectors = getSelectors(fragment);\n      if (!selectors.length) {\n        continue;\n      }\n      if (isSkip(parentToken.name)) {\n        selectors = [joinToken(fragment)];\n      }\n      let tokenName = selectors.pop();\n      let skip = isSkip(...selectors, parentToken.name, tokenName);\n      if (tokenName === 'style') {\n        rules.push({\n          type: 'block',\n          name: tokenName,\n          value: readStyle(iter)\n        });\n      } else {\n        let block = resolveId(walk(iter, splitTimes(tokenName, {\n          type: 'block',\n          name: tokenName,\n          value: []\n        })), skip);\n        while (tokenName = selectors.pop()) {\n          block = resolveId(splitTimes(tokenName, {\n            type: 'block',\n            name: tokenName,\n            value: [block]\n          }), skip);\n        }\n        rules.push(block);\n      }\n      fragment = [];\n    } else if (curr.isSymbol(':') && !stack.length && !isSpecialProperty(prev, next) && fragment.length) {\n      let props = getGroups(fragment, token => token.isSymbol(','));\n      let intial = {\n        type: 'statement',\n        name: 'unkown',\n        value: ''\n      };\n      if (props.length > 1) {\n        intial.origin = {\n          name: props\n        };\n      }\n      let statement = readStatement(iter, intial);\n      let groupdValue = parseValueGroup(statement.value);\n      let expand = props.length > 1 && groupdValue.length === props.length;\n      props.forEach((prop, i) => {\n        let item = Object.assign({}, statement, {\n          name: prop\n        });\n        if (/^\\-\\-/.test(prop)) {\n          item.variable = true;\n        }\n        if (expand) {\n          item.value = groupdValue[i];\n        }\n        if (/viewBox/i.test(prop)) {\n          item.detail = parseViewBox(item.value, item._valueTokens);\n        }\n        delete item._valueTokens;\n        rules.push(item);\n      });\n      if (isBlock(tokenType)) {\n        parentToken.value = rules;\n      }\n      fragment = [];\n    } else if (curr.isSymbol(';')) {\n      if (rules.length && fragment.length) {\n        rules[rules.length - 1].value += ';' + joinToken(fragment);\n        fragment = [];\n      }\n    } else {\n      fragment.push(curr);\n    }\n  }\n  if (rules.length && isBlock(tokenType)) {\n    parentToken.value = rules;\n  }\n  return tokenType ? parentToken : rules;\n}\nfunction isSpecialProperty(prev, next) {\n  const names = ['xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'];\n  let prevValue = prev && prev.value;\n  let nextValue = next && next.value;\n  return names.includes(prevValue + ':' + nextValue);\n}\nfunction joinToken(tokens) {\n  return tokens.filter((token, i) => {\n    if (token.isSymbol(';', '}') && i === tokens.length - 1) return false;\n    return true;\n  }).map(n => n.value).join('');\n}\nfunction resolveId(block, skip) {\n  let name = block.name || '';\n  let [tokenName, ...ids] = name.split(/#/);\n  let id = ids[ids.length - 1];\n  if (tokenName && id && !skip) {\n    block.name = tokenName;\n    block.value.push({\n      type: 'statement',\n      name: 'id',\n      value: id\n    });\n  }\n  return block;\n}\nfunction getGroups(tokens, fn) {\n  let group = [];\n  let temp = [];\n  tokens.forEach(token => {\n    if (fn(token)) {\n      group.push(joinToken(temp));\n      temp = [];\n    } else {\n      temp.push(token);\n    }\n  });\n  if (temp.length) {\n    group.push(joinToken(temp));\n  }\n  return group;\n}\nfunction getSelectors(tokens) {\n  let result = [];\n  let it = iterator(tokens);\n  let temp = [];\n  let hasSymbol;\n  while (it.next()) {\n    let {\n      prev,\n      curr,\n      next\n    } = it.get();\n    let isTimeSymbol = prev && next && curr.value === 'x' && prev.isNumber() && next.isNumber();\n    if (curr.isWord() && !hasSymbol && !isTimeSymbol) {\n      result.push(curr.value.trim());\n    } else {\n      result[result.length - 1] = (result[result.length - 1] + curr.value).trim();\n    }\n    if (curr.isSymbol()) {\n      hasSymbol = true;\n    } else if (!curr.isSpace()) {\n      hasSymbol = false;\n    }\n  }\n  return result;\n}\nfunction parseViewBox(value, tokens) {\n  const viewBox = {\n    value: []\n  };\n  let temp;\n  if (!Array.isArray(tokens)) {\n    return viewBox;\n  }\n  for (let token of tokens) {\n    if (token.isSpace() || token.isSymbol(',', ';')) {\n      continue;\n    }\n    if (viewBox.value.length < 4 && token.isNumber()) {\n      viewBox.value.push(Number(token.value));\n    } else if (token.isNumber() && temp) {\n      viewBox[temp] = Number(token.value);\n      temp = null;\n    } else if (token.isWord()) {\n      temp = token.value;\n    }\n  }\n  return viewBox;\n}\nfunction splitTimes(name, object) {\n  let target = Object.assign({}, object);\n  if (/\\*\\s*[0-9]/.test(name)) {\n    let [tokenName, times] = name.split('*');\n    if (times) {\n      target.times = times.trim();\n      target.pureName = tokenName.trim();\n    }\n  }\n  return target;\n}\nfunction isSkip() {\n  for (var _len = arguments.length, names = new Array(_len), _key = 0; _key < _len; _key++) {\n    names[_key] = arguments[_key];\n  }\n  return names.some(n => n === 'style');\n}\nfunction isBlock(type) {\n  return type === 'block';\n}\nfunction skipHeadSVG(block) {\n  let headSVG,\n    headVariables = [];\n  for (let item of block.value) {\n    if (item.name === 'svg') {\n      headSVG = item;\n    }\n    if (item.variable) {\n      headVariables.push(item);\n    }\n  }\n  if (headSVG && Array.isArray(headSVG.value)) {\n    for (let variable of headVariables) {\n      if (!headSVG.value.find(n => n.name == variable.name)) {\n        headSVG.value.unshift(variable);\n      }\n    }\n    return headSVG;\n  }\n  return block;\n}\nfunction parse(source, root) {\n  let iter = iterator(scan(source));\n  let tokens = walk(iter, root || {\n    type: 'block',\n    name: 'svg',\n    value: []\n  });\n  return skipHeadSVG(tokens);\n}\nexport default parse;","map":{"version":3,"names":["scan","iterator","parseValueGroup","readStatement","iter","token","fragment","inlineBlock","stackQuote","stackParen","next","curr","get","isSymbol","length","push","pop","status","isStatementBreak","selectors","getSelectors","tokenName","skip","isSkip","resolveId","walk","splitTimes","type","inline","name","value","_valueTokens","joinToken","origin","readStyle","stack","style","join","parentToken","rules","tokenType","prev","isBlockBreak","isBlock","last","block","isSpecialProperty","props","getGroups","intial","statement","groupdValue","expand","forEach","prop","i","item","Object","assign","test","variable","detail","parseViewBox","names","prevValue","nextValue","includes","tokens","filter","map","n","ids","split","id","fn","group","temp","result","it","hasSymbol","isTimeSymbol","isNumber","isWord","trim","isSpace","viewBox","Array","isArray","Number","object","target","times","pureName","some","skipHeadSVG","headSVG","headVariables","find","unshift","parse","source","root"],"sources":["/Users/mariaeduardatc/Documents/GitHub/website/node_modules/css-doodle/src/parser/parse-svg.js"],"sourcesContent":["import { scan, iterator } from './tokenizer.js';\nimport parseValueGroup from './parse-value-group.js';\n\nfunction readStatement(iter, token) {\n  let fragment = [];\n  let inlineBlock;\n  let stackQuote = [];\n  let stackParen = [];\n  while (iter.next()) {\n    let { curr, next } = iter.get();\n    if (curr.isSymbol('(') && !stackQuote.length) {\n      stackParen.push(curr);\n    } else if (curr.isSymbol(')') && !stackQuote.length) {\n      stackParen.pop();\n    }\n    if (curr.isSymbol(\"'\", '\"')) {\n      if (curr.status === 'open') {\n        stackQuote.push(curr);\n      } else {\n        stackQuote.pop();\n      }\n    }\n    let isStatementBreak = !stackQuote.length\n      && !stackParen.length\n      && (!next || curr.isSymbol(';') || next.isSymbol('}'));\n\n    if (curr.isSymbol(\"'\", '\"')) {\n      if ((next && next.isSymbol('}')) && !stackQuote.length) {\n        isStatementBreak = true;\n      }\n    }\n    if (!stackParen.length && !stackQuote.length && curr.isSymbol('{')) {\n      let selectors = getSelectors(fragment);\n      if (!selectors.length) {\n        continue;\n      }\n      let tokenName = selectors.pop();\n      let skip = isSkip(...selectors, tokenName);\n      inlineBlock = resolveId(walk(iter, splitTimes(tokenName, {\n        type: 'block',\n        inline: true,\n        name: tokenName,\n        value: [],\n      })), skip);\n\n      while (tokenName = selectors.pop()) {\n        inlineBlock = resolveId(splitTimes(tokenName, {\n          type: 'block',\n          name: tokenName,\n          value: [inlineBlock]\n        }), skip);\n      }\n      break;\n    }\n    fragment.push(curr);\n    if (isStatementBreak) {\n      break;\n    }\n  }\n  if (fragment.length && !inlineBlock) {\n    token._valueTokens = fragment;\n    token.value = joinToken(fragment);\n  } else if (inlineBlock) {\n    token.value = inlineBlock;\n  }\n  if (token.origin) {\n    token.origin.value = token.value;\n  }\n  return token;\n}\n\nfunction readStyle(iter) {\n  let stack = [];\n  let style = [];\n  while (iter.next()) {\n    let { curr } = iter.get();\n    if (curr.isSymbol('{')) {\n      stack.push(curr.value);\n    } else if (curr.isSymbol('}')) {\n      if (stack.length) {\n        stack.pop();\n      } else {\n        break;\n      }\n    }\n    style.push(curr.value);\n  }\n  return style.join('');\n}\n\nfunction walk(iter, parentToken) {\n  let rules = [];\n  let fragment = [];\n  let tokenType = parentToken && parentToken.type || '';\n  let stack = [];\n\n  while (iter.next()) {\n    let { prev, curr, next } = iter.get();\n    if (curr.isSymbol('(')) {\n      stack.push(curr.value);\n    }\n    if (curr.isSymbol(')')) {\n      stack.pop();\n    }\n    let isBlockBreak = !next || curr.isSymbol('}');\n    if (isBlock(tokenType) && isBlockBreak) {\n      if (!next && rules.length && !curr.isSymbol('}')) {\n        let last = rules[rules.length - 1].value;\n        if (typeof last === 'string') {\n          rules[rules.length - 1].value += (';' + curr.value);\n        }\n      }\n      parentToken.value = rules;\n      break;\n    }\n    else if (curr.isSymbol('{')) {\n      let selectors = getSelectors(fragment);\n      if (!selectors.length) {\n        continue;\n      }\n      if (isSkip(parentToken.name)) {\n        selectors = [joinToken(fragment)];\n      }\n      let tokenName = selectors.pop();\n      let skip = isSkip(...selectors, parentToken.name, tokenName);\n\n      if (tokenName === 'style') {\n        rules.push({\n          type: 'block',\n          name: tokenName,\n          value: readStyle(iter)\n        });\n      } else {\n        let block = resolveId(walk(iter, splitTimes(tokenName, {\n          type: 'block',\n          name: tokenName,\n          value: []\n        })), skip);\n\n        while (tokenName = selectors.pop()) {\n          block = resolveId(splitTimes(tokenName, {\n            type: 'block',\n            name: tokenName,\n            value: [block]\n          }), skip);\n        }\n        rules.push(block);\n      }\n      fragment = [];\n    }\n    else if (\n      curr.isSymbol(':')\n      && !stack.length\n      && !isSpecialProperty(prev, next)\n      && fragment.length\n    ) {\n      let props = getGroups(fragment, token => token.isSymbol(','));\n      let intial = {\n        type: 'statement',\n        name: 'unkown',\n        value: ''\n      }\n      if (props.length > 1) {\n        intial.origin = {\n          name: props\n        };\n      }\n      let statement = readStatement(iter, intial);\n      let groupdValue = parseValueGroup(statement.value);\n      let expand = (props.length > 1 && groupdValue.length === props.length);\n\n      props.forEach((prop, i) => {\n        let item = Object.assign({}, statement, { name: prop });\n        if (/^\\-\\-/.test(prop)) {\n          item.variable = true;\n        }\n        if (expand) {\n          item.value = groupdValue[i];\n        }\n        if (/viewBox/i.test(prop)) {\n          item.detail = parseViewBox(item.value, item._valueTokens);\n        }\n        delete item._valueTokens;\n        rules.push(item);\n      });\n      if (isBlock(tokenType)) {\n        parentToken.value = rules;\n      }\n      fragment = [];\n    }\n    else if (curr.isSymbol(';')) {\n      if (rules.length && fragment.length) {\n        rules[rules.length - 1].value += (';' + joinToken(fragment));\n        fragment = [];\n      }\n    }\n    else {\n      fragment.push(curr);\n    }\n  }\n\n  if (rules.length && isBlock(tokenType)) {\n    parentToken.value = rules;\n  }\n  return tokenType ? parentToken : rules;\n}\n\nfunction isSpecialProperty(prev, next) {\n  const names = [\n    'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role',\n    'xlink:show',    'xlink:title',   'xlink:type',\n    'xml:base',      'xml:lang',      'xml:space',\n  ];\n  let prevValue = prev && prev.value;\n  let nextValue = next && next.value;\n  return names.includes(prevValue + ':' + nextValue);\n}\n\nfunction joinToken(tokens) {\n  return tokens\n    .filter((token, i) => {\n      if (token.isSymbol(';', '}') && i === tokens.length - 1) return false;\n      return true;\n    })\n    .map(n => n.value).join('');\n}\n\nfunction resolveId(block, skip) {\n  let name = block.name || '';\n  let [tokenName, ...ids] = name.split(/#/);\n  let id = ids[ids.length - 1];\n  if (tokenName && id && !skip) {\n    block.name = tokenName;\n    block.value.push({\n      type: 'statement',\n      name: 'id',\n      value: id,\n    });\n  }\n  return block;\n}\n\nfunction getGroups(tokens, fn) {\n  let group = [];\n  let temp = [];\n  tokens.forEach(token => {\n    if (fn(token)) {\n      group.push(joinToken(temp));\n      temp = [];\n    } else {\n      temp.push(token);\n    }\n  });\n  if (temp.length) {\n    group.push(joinToken(temp));\n  }\n  return group;\n}\n\nfunction getSelectors(tokens) {\n  let result = [];\n  let it = iterator(tokens);\n  let temp = [];\n  let hasSymbol;\n  while (it.next()) {\n    let { prev, curr, next } = it.get();\n    let isTimeSymbol = (\n      prev && next &&\n      curr.value === 'x' &&\n      prev.isNumber()  &&\n      next.isNumber()\n    );\n    if (curr.isWord() && !hasSymbol && !isTimeSymbol) {\n      result.push(curr.value.trim());\n    } else {\n      result[result.length - 1] =\n        (result[result.length - 1] + curr.value).trim();\n    }\n    if (curr.isSymbol()) {\n      hasSymbol = true;\n    } else if (!curr.isSpace()) {\n      hasSymbol = false;\n    }\n  }\n  return result;\n}\n\nfunction parseViewBox(value, tokens) {\n  const viewBox = { value: [] };\n  let temp;\n  if (!Array.isArray(tokens)) {\n    return viewBox;\n  }\n  for (let token of tokens) {\n    if (token.isSpace() || token.isSymbol(',', ';')) {\n      continue;\n    }\n    if (viewBox.value.length < 4 && token.isNumber()) {\n      viewBox.value.push(Number(token.value));\n    }\n    else if (token.isNumber() && temp) {\n      viewBox[temp] = Number(token.value);\n      temp = null;\n    }\n    else if (token.isWord()) {\n      temp = token.value;\n    }\n  }\n  return viewBox;\n}\n\nfunction splitTimes(name, object) {\n  let target = Object.assign({}, object);\n  if (/\\*\\s*[0-9]/.test(name)) {\n    let [tokenName, times] = name.split('*');\n    if (times) {\n      target.times = times.trim();\n      target.pureName = tokenName.trim();\n    }\n  }\n  return target;\n}\n\nfunction isSkip(...names) {\n  return names.some(n => n === 'style');\n}\n\nfunction isBlock(type) {\n  return type === 'block';\n}\n\nfunction skipHeadSVG(block) {\n  let headSVG, headVariables = [];\n  for (let item of block.value) {\n    if (item.name === 'svg') {\n      headSVG = item;\n    }\n    if (item.variable) {\n      headVariables.push(item);\n    }\n  }\n  if (headSVG && Array.isArray(headSVG.value)) {\n    for (let variable of headVariables) {\n      if (!headSVG.value.find(n => n.name == variable.name)) {\n        headSVG.value.unshift(variable);\n      }\n    }\n    return headSVG;\n  }\n  return block;\n}\n\nfunction parse(source, root) {\n  let iter = iterator(scan(source));\n  let tokens = walk(iter, root || {\n    type: 'block',\n    name: 'svg',\n    value: []\n  });\n  return skipHeadSVG(tokens);\n}\n\nexport default parse;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}