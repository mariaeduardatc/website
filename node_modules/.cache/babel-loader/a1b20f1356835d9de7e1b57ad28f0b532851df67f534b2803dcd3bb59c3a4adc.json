{"ast":null,"code":"import { next_id } from '../utils/index.js';\nconst NS = 'http://www.w3.org/2000/svg';\nconst NSXLink = 'http://www.w3.org/1999/xlink';\nconst nextId = next_id();\nclass Tag {\n  constructor(name) {\n    let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n    if (!name) {\n      throw new Error(\"Tag name is required\");\n    }\n    this.name = name;\n    this.body = [];\n    this.attrs = {};\n    if (this.isTextNode()) {\n      this.body = value;\n    }\n  }\n  isTextNode() {\n    return this.name === 'text-node';\n  }\n  find(target) {\n    let id = target.attrs.id;\n    let name = target.name;\n    if (Array.isArray(this.body) && id !== undefined) {\n      return this.body.find(tag => tag.attrs.id === id && tag.name === name);\n    }\n  }\n  append(tag) {\n    if (!this.isTextNode()) {\n      this.body.push(tag);\n    }\n  }\n  merge(tag) {\n    for (let [name, value] of Object.entries(tag.attrs)) {\n      this.attrs[name] = value;\n    }\n    if (Array.isArray(tag.body)) {\n      this.body.push(...tag.body);\n    }\n  }\n  attr(name, value) {\n    if (!this.isTextNode()) {\n      if (value === undefined) {\n        return this.attrs[name];\n      }\n      return this.attrs[name] = value;\n    }\n  }\n  toString() {\n    if (this.isTextNode()) {\n      return removeQuotes(this.body);\n    }\n    let attrs = [''];\n    let body = [];\n    for (let [name, value] of Object.entries(this.attrs)) {\n      value = removeQuotes(value);\n      attrs.push(`${name}=\"${value}\"`);\n    }\n    for (let tag of this.body) {\n      body.push(tag.toString());\n    }\n    return `<${this.name}${attrs.join(' ')}>${body.join('')}</${this.name}>`;\n  }\n}\nfunction composeStyleRule(name, value) {\n  return `${name}:${value};`;\n}\nfunction removeQuotes(text) {\n  text = String(text);\n  let double = text.startsWith('\"') && text.endsWith('\"');\n  let single = text.startsWith(\"'\") && text.endsWith(\"'\");\n  if (double || single) {\n    return text.substring(1, text.length - 1);\n  }\n  return text;\n}\nfunction transformViewBox(token) {\n  let viewBox = token.detail.value;\n  let p = token.detail.padding || token.detail.p || token.detail.expand;\n  if (!viewBox.length) {\n    return '';\n  }\n  let [x, y, w, h] = viewBox;\n  if (p) {\n    [x, y, w, h] = [x - p, y - p, w + p * 2, h + p * 2];\n  }\n  return `${x} ${y} ${w} ${h}`;\n}\nfunction isGraphicElement(name) {\n  return name === 'path' || name === 'line' || name === 'circle' || name === 'ellipse' || name === 'rect' || name === 'polygon' || name === 'polyline';\n}\nfunction generate(token, element, parent, root) {\n  let inlineId;\n  if (!element) {\n    element = new Tag('root');\n  }\n  if (token.type === 'block') {\n    // style tag\n    if (token.name === 'style') {\n      let el = new Tag('style');\n      el.append(token.value);\n      element.append(el);\n    }\n    // normal svg elements\n    else {\n      let el = new Tag(token.name);\n      if (!root) {\n        root = el;\n        root.attr('xmlns', NS);\n      }\n      for (let block of token.value) {\n        let id = generate(block, el, token, root);\n        if (id) {\n          inlineId = id;\n        }\n      }\n      // generate id for inline block if no id is found\n      if (token.inline) {\n        let found = token.value.find(n => n.type === 'statement' && n.name === 'id');\n        if (found) {\n          inlineId = found.value;\n        } else {\n          inlineId = nextId(token.name);\n          el.attr('id', inlineId);\n        }\n      }\n      let existedTag = root.find(el);\n      if (existedTag) {\n        existedTag.merge(el);\n      } else {\n        element.append(el);\n      }\n    }\n  }\n  if (token.type === 'statement' && !token.variable) {\n    if (token.name === 'content') {\n      let text = new Tag('text-node', token.value);\n      element.append(text);\n    }\n    // inline style\n    else if (token.name.startsWith('style ')) {\n      let name = (token.name.split('style ')[1] || '').trim();\n      if (name.length) {\n        let style = element.attr('style') || '';\n        element.attr('style', style + composeStyleRule(name, token.value));\n      }\n    } else {\n      let value = token.value;\n      // handle inline block value\n      if (value && value.type === 'block') {\n        let id = generate(token.value, root, token, root);\n        value = `url(#${id})`;\n        if (token.name === 'xlink:href' || token.name === 'href') {\n          value = `#${id}`;\n        }\n      }\n      if (/viewBox/i.test(token.name)) {\n        value = transformViewBox(token, value);\n        if (value) {\n          element.attr(token.name, value);\n        }\n      } else if ((token.name === 'draw' || token.name === 'animate') && isGraphicElement(parent && parent.name)) {\n        let [dur, repeatCount] = String(value).split(/\\s+/);\n        if (dur === 'indefinite' || dur === 'infinite' || /\\d$/.test(dur)) {\n          [dur, repeatCount] = [repeatCount, dur];\n        }\n        if (repeatCount === 'infinite') {\n          repeatCount = 'indefinite';\n        }\n        element.attr('stroke-dasharray', 10);\n        element.attr('pathLength', 10);\n        let animate = new Tag('animate');\n        animate.attr('attributeName', 'stroke-dashoffset');\n        animate.attr('from', 10);\n        animate.attr('to', 0);\n        animate.attr('dur', dur);\n        if (repeatCount) {\n          animate.attr('repeatCount', repeatCount);\n        }\n        element.append(animate);\n      } else {\n        element.attr(token.name, value);\n      }\n      if (token.name.includes('xlink:')) {\n        root.attr('xmlns:xlink', NSXLink);\n      }\n    }\n  }\n  if (!parent) {\n    return root.toString();\n  }\n  return inlineId;\n}\nfunction generate_svg(token) {\n  return generate(token);\n}\nexport { generate_svg };","map":{"version":3,"names":["next_id","NS","NSXLink","nextId","Tag","constructor","name","value","Error","body","attrs","isTextNode","find","target","id","Array","isArray","undefined","tag","append","push","merge","Object","entries","attr","toString","removeQuotes","join","composeStyleRule","text","String","double","startsWith","endsWith","single","substring","length","transformViewBox","token","viewBox","detail","p","padding","expand","x","y","w","h","isGraphicElement","generate","element","parent","root","inlineId","type","el","block","inline","found","n","existedTag","variable","split","trim","style","test","dur","repeatCount","animate","includes","generate_svg"],"sources":["/Users/mariaeduardatc/Documents/GitHub/website/node_modules/css-doodle/src/generator/svg.js"],"sourcesContent":["import { next_id } from '../utils/index.js';\n\nconst NS = 'http://www.w3.org/2000/svg';\nconst NSXLink = 'http://www.w3.org/1999/xlink';\nconst nextId = next_id();\n\nclass Tag {\n  constructor(name, value = '') {\n    if (!name) {\n      throw new Error(\"Tag name is required\");\n    }\n    this.name = name;\n    this.body = [];\n    this.attrs = {};\n    if (this.isTextNode()) {\n      this.body = value;\n    }\n  }\n  isTextNode() {\n    return this.name === 'text-node';\n  }\n  find(target) {\n    let id = target.attrs.id;\n    let name = target.name;\n    if (Array.isArray(this.body) && id !== undefined) {\n      return this.body.find(tag => tag.attrs.id === id && tag.name === name);\n    }\n  }\n  append(tag) {\n    if (!this.isTextNode()) {\n      this.body.push(tag);\n    }\n  }\n  merge(tag) {\n    for (let [name, value] of Object.entries(tag.attrs)) {\n      this.attrs[name] = value;\n    }\n    if (Array.isArray(tag.body)) {\n      this.body.push(...tag.body);\n    }\n  }\n  attr(name, value) {\n    if (!this.isTextNode()) {\n      if (value === undefined) {\n        return this.attrs[name];\n      }\n      return this.attrs[name] = value;\n    }\n  }\n  toString() {\n    if (this.isTextNode()) {\n      return removeQuotes(this.body);\n    }\n    let attrs = [''];\n    let body = [];\n    for (let [name, value] of Object.entries(this.attrs)) {\n      value = removeQuotes(value);\n      attrs.push(`${name}=\"${value}\"`);\n    }\n    for (let tag of this.body) {\n      body.push(tag.toString());\n    }\n    return `<${this.name}${attrs.join(' ')}>${body.join('')}</${this.name}>`;\n  }\n}\n\nfunction composeStyleRule(name, value) {\n  return `${name}:${value};`\n}\n\nfunction removeQuotes(text) {\n  text = String(text);\n  let double = text.startsWith('\"') && text.endsWith('\"');\n  let single = text.startsWith(\"'\") && text.endsWith(\"'\");\n  if (double || single) {\n    return text.substring(1, text.length - 1);\n  }\n  return text;\n}\n\nfunction transformViewBox(token) {\n  let viewBox = token.detail.value;\n  let p = token.detail.padding || token.detail.p || token.detail.expand;\n  if (!viewBox.length) {\n    return '';\n  }\n  let [x, y, w, h] = viewBox;\n  if (p) {\n    [x, y, w, h] = [x-p, y-p, w+p*2, h+p*2];\n  }\n  return `${x} ${y} ${w} ${h}`;\n}\n\nfunction isGraphicElement(name) {\n  return name === 'path'\n    || name === 'line'\n    || name === 'circle'\n    || name === 'ellipse'\n    || name === 'rect'\n    || name === 'polygon'\n    || name === 'polyline';\n}\n\nfunction generate(token, element, parent, root) {\n  let inlineId;\n  if (!element) {\n    element = new Tag('root');\n  }\n  if (token.type === 'block') {\n    // style tag\n    if (token.name === 'style') {\n      let el = new Tag('style');\n      el.append(token.value);\n      element.append(el);\n    }\n    // normal svg elements\n    else {\n      let el = new Tag(token.name);\n      if (!root) {\n        root = el;\n        root.attr('xmlns', NS);\n      }\n      for (let block of token.value) {\n        let id = generate(block, el, token, root);\n        if (id) { inlineId = id }\n      }\n      // generate id for inline block if no id is found\n      if (token.inline) {\n        let found = token.value.find(n => n.type === 'statement' && n.name === 'id');\n        if (found) {\n          inlineId = found.value;\n        } else {\n          inlineId = nextId(token.name);\n          el.attr('id', inlineId);\n        }\n      }\n      let existedTag = root.find(el);\n      if (existedTag) {\n        existedTag.merge(el);\n      } else {\n        element.append(el);\n      }\n    }\n  }\n  if (token.type === 'statement' && !token.variable) {\n    if (token.name === 'content') {\n      let text = new Tag('text-node', token.value);\n      element.append(text);\n    }\n    // inline style\n    else if (token.name.startsWith('style ')) {\n      let name = (token.name.split('style ')[1] || '').trim();\n      if (name.length) {\n        let style = element.attr('style') || '';\n        element.attr('style', style + composeStyleRule(name, token.value));\n      }\n    }\n    else {\n      let value = token.value;\n      // handle inline block value\n      if (value && value.type === 'block') {\n        let id = generate(token.value, root, token, root);\n        value = `url(#${id})`;\n        if (token.name === 'xlink:href' || token.name === 'href') {\n          value = `#${id}`;\n        }\n      }\n      if (/viewBox/i.test(token.name)) {\n        value = transformViewBox(token, value);\n        if (value) {\n          element.attr(token.name, value);\n        }\n      }\n      else if ((token.name === 'draw' || token.name === 'animate') && isGraphicElement(parent && parent.name)) {\n        let [dur, repeatCount] = String(value).split(/\\s+/);\n        if (dur === 'indefinite' || dur === 'infinite' || /\\d$/.test(dur)) {\n          [dur, repeatCount] = [repeatCount, dur];\n        }\n        if (repeatCount === 'infinite') {\n          repeatCount = 'indefinite';\n        }\n        element.attr('stroke-dasharray', 10);\n        element.attr('pathLength', 10);\n        let animate = new Tag('animate');\n        animate.attr('attributeName', 'stroke-dashoffset');\n        animate.attr('from', 10);\n        animate.attr('to', 0);\n        animate.attr('dur', dur);\n        if (repeatCount) {\n          animate.attr('repeatCount', repeatCount);\n        }\n        element.append(animate);\n      }\n      else {\n        element.attr(token.name, value);\n      }\n      if (token.name.includes('xlink:')) {\n        root.attr('xmlns:xlink', NSXLink);\n      }\n    }\n  }\n  if (!parent) {\n    return root.toString();\n  }\n  return inlineId;\n}\n\nfunction generate_svg(token) {\n  return generate(token);\n}\n\nexport {\n  generate_svg,\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}