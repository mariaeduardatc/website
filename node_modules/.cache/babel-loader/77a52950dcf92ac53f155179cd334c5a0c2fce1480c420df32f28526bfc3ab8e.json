{"ast":null,"code":"import Func from '../function.js';\nimport Property from '../property.js';\nimport Selector from '../selector.js';\nimport parse_value_group from '../parser/parse-value-group.js';\nimport calc from '../calc.js';\nimport { uniform_time } from '../uniforms.js';\nimport { seedrandom } from '../lib/seedrandom.js';\nimport { prefixer } from '../utils/prefixer.js';\nimport { maybe, cell_id, is_nil, get_value, lerp, unique_id } from '../utils/index.js';\nimport { join, make_array, remove_empty_values } from '../utils/list.js';\nfunction is_host_selector(s) {\n  return /^\\:(host|doodle)/.test(s);\n}\nfunction is_parent_selector(s) {\n  return /^\\:(container|parent)/.test(s);\n}\nfunction is_special_selector(s) {\n  return is_host_selector(s) || is_parent_selector(s);\n}\nfunction is_pseudo_selecotr(s) {\n  return /\\:before|\\:after/.test(s);\n}\nconst MathFunc = {};\nfor (let name of Object.getOwnPropertyNames(Math)) {\n  MathFunc[name] = () => function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    if (typeof Math[name] === 'number') {\n      return Math[name];\n    }\n    args = args.map(n => calc(get_value(n)));\n    return Math[name](...args);\n  };\n}\nclass Rules {\n  constructor(tokens) {\n    this.tokens = tokens;\n    this.rules = {};\n    this.props = {};\n    this.keyframes = {};\n    this.grid = null;\n    this.seed = null;\n    this.is_grid_defined = false;\n    this.is_gap_defined = false;\n    this.coords = [];\n    this.doodles = {};\n    this.canvas = {};\n    this.pattern = {};\n    this.shaders = {};\n    this.reset();\n    this.custom_properties = {};\n    this.uniforms = {};\n    this.content = {};\n  }\n  reset() {\n    this.styles = {\n      host: '',\n      container: '',\n      cells: '',\n      keyframes: ''\n    };\n    this.coords = [];\n    this.doodles = {};\n    this.canvas = {};\n    this.pattern = {};\n    this.shaders = {};\n    this.content = {};\n    for (let key in this.rules) {\n      if (key.startsWith('#c')) {\n        delete this.rules[key];\n      }\n    }\n  }\n  add_rule(selector, rule) {\n    let rules = this.rules[selector];\n    if (!rules) {\n      rules = this.rules[selector] = [];\n    }\n    rules.push.apply(rules, make_array(rule));\n  }\n  pick_func(name) {\n    if (name.startsWith('$')) name = 'calc';\n    return Func[name] || MathFunc[name];\n  }\n  apply_func(fn, coords, args, fname) {\n    let contextedVariable = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    let _fn = fn(...make_array(coords));\n    let input = [];\n    args.forEach(arg => {\n      let type = typeof arg.value;\n      let is_string_or_number = type === 'number' || type === 'string';\n      if (!arg.cluster && is_string_or_number) {\n        input.push(...parse_value_group(arg.value, {\n          noSpace: true\n        }));\n      } else {\n        if (typeof arg === 'function') {\n          input.push(arg);\n        } else if (!is_nil(arg.value)) {\n          let value = get_value(arg.value);\n          input.push(value);\n        }\n      }\n    });\n    input = make_array(remove_empty_values(input));\n    if (typeof _fn === 'function') {\n      if (fname.startsWith('$')) {\n        let group = Object.assign({}, this.custom_properties['host'], this.custom_properties['container'], this.custom_properties[coords.count], contextedVariable);\n        let context = {};\n        let unit = '';\n        for (let [name, key] of Object.entries(group)) {\n          context[name.substr(2)] = key;\n        }\n        if (fname.length > 1) {\n          unit = fname.split('$')[1] ?? '';\n        }\n        return _fn(input, context) + unit;\n      }\n      return _fn(...input);\n    }\n    return _fn;\n  }\n  compose_aname() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    return args.join('-');\n  }\n  compose_selector(_ref) {\n    let {\n      x,\n      y,\n      z\n    } = _ref;\n    let pseudo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n    return `#${cell_id(x, y, z)}${pseudo}`;\n  }\n  is_composable(name) {\n    return ['doodle', 'shaders', 'canvas', 'pattern'].includes(name);\n  }\n  read_var(value, coords, contextedVariable) {\n    let count = coords.count;\n    let group = Object.assign({}, this.custom_properties['host'], this.custom_properties['container'], this.custom_properties[count], contextedVariable);\n    if (group[value] !== undefined) {\n      let result = String(group[value]).trim();\n      if (result[0] == '(') {\n        let last = result[result.length - 1];\n        if (last === ')') {\n          result = result.substring(1, result.length - 1);\n        }\n      }\n      return result.replace(/;+$/g, '');\n    }\n    return value;\n  }\n  compose_argument(argument, coords) {\n    var _this = this;\n    let extra = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    let parent = arguments.length > 3 ? arguments[3] : undefined;\n    let contextedVariable = arguments.length > 4 ? arguments[4] : undefined;\n    if (!coords.extra) coords.extra = [];\n    coords.extra.push(extra);\n    let result = argument.map(arg => {\n      if (arg.type === 'text') {\n        if (/^\\-\\-\\w/.test(arg.value)) {\n          if (parent && parent.name === '@var') {\n            return arg.value;\n          }\n          return this.read_var(arg.value, coords, contextedVariable);\n        }\n        return arg.value;\n      } else if (arg.type === 'func') {\n        let fname = arg.name.substr(1);\n        let fn = this.pick_func(fname);\n        if (typeof fn === 'function') {\n          this.check_uniforms(fname);\n          if (this.is_composable(fname)) {\n            let value = get_value((arg.arguments[0] || [])[0]);\n            let temp_arg;\n            if (fname === 'doodle') {\n              if (/^\\d/.test(value)) {\n                temp_arg = value;\n                value = get_value((val.arguments[1] || [])[0]);\n              }\n            }\n            if (!is_nil(value)) {\n              switch (fname) {\n                case 'doodle':\n                  return this.compose_doodle(this.inject_variables(value, coords.count), temp_arg);\n                case 'shaders':\n                  return this.compose_shaders(value, coords);\n                case 'canvas':\n                  return this.compose_canvas(value, arg.arguments.slice(1));\n                case 'pattern':\n                  return this.compose_pattern(value, coords);\n              }\n            }\n          }\n          coords.position = arg.position;\n          let args = arg.arguments.map(n => {\n            return fn.lazy ? function () {\n              for (var _len3 = arguments.length, extra = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n                extra[_key3] = arguments[_key3];\n              }\n              return _this.compose_argument(n, coords, extra, arg, contextedVariable);\n            } : this.compose_argument(n, coords, extra, arg, contextedVariable);\n          });\n          return this.apply_func(fn, coords, args, fname, contextedVariable);\n        } else {\n          return arg.name;\n        }\n      }\n    });\n    coords.extra.pop();\n    return {\n      cluster: argument.cluster,\n      value: result.length >= 2 ? {\n        value: result.join('')\n      } : result[0]\n    };\n  }\n  compose_doodle(doodle, arg) {\n    let id = unique_id('doodle');\n    this.doodles[id] = {\n      doodle,\n      arg\n    };\n    return '${' + id + '}';\n  }\n  compose_shaders(shader, _ref2) {\n    let {\n      x,\n      y,\n      z\n    } = _ref2;\n    let id = unique_id('shader');\n    this.shaders[id] = {\n      id: '--' + id,\n      shader,\n      cell: cell_id(x, y, z)\n    };\n    return '${' + id + '}';\n  }\n  compose_pattern(code, _ref3) {\n    let {\n      x,\n      y,\n      z\n    } = _ref3;\n    let id = unique_id('pattern');\n    this.pattern[id] = {\n      id: '--' + id,\n      code,\n      cell: cell_id(x, y, z)\n    };\n    return '${' + id + '}';\n  }\n  compose_canvas(code) {\n    let rest = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let commands = code;\n    let result = rest.map(group => get_value(group[0])).join(',');\n    if (result.length) {\n      commands = code + ',' + result;\n    }\n    let id = unique_id('canvas');\n    this.canvas[id] = {\n      code: commands\n    };\n    return '${' + id + '}';\n  }\n  check_uniforms(name) {\n    switch (name) {\n      case 'ut':\n      case 't':\n        this.uniforms.time = true;\n        break;\n      case 'ux':\n        this.uniforms.mousex = true;\n        break;\n      case 'uy':\n        this.uniforms.mousey = true;\n        break;\n      case 'uw':\n        this.uniforms.width = true;\n        break;\n      case 'uh':\n        this.uniforms.height = true;\n        break;\n    }\n  }\n  inject_variables(value, count) {\n    let group = Object.assign({}, this.custom_properties['host'], this.custom_properties['container'], this.custom_properties[count]);\n    let variables = [];\n    for (let [name, key] of Object.entries(group)) {\n      variables.push(`${name}: ${key};`);\n    }\n    variables = variables.join('');\n    if (variables.length) {\n      return `:doodle { ${variables} }` + value;\n    }\n    return value;\n  }\n  compose_variables(variables, coords) {\n    let result = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    for (let [name, value] of Object.entries(variables)) {\n      let value_group = value.reduce((ret, v) => {\n        let composed = this.compose_value(v, coords, result);\n        if (composed && composed.value) {\n          ret.push(composed.value);\n        }\n        return ret;\n      }, []);\n      result[name] = value_group.join(', ');\n    }\n    return result;\n  }\n  compose_value(value, coords) {\n    var _this2 = this;\n    let contextedVariable = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (!Array.isArray(value)) {\n      return {\n        value: '',\n        extra: ''\n      };\n    }\n    let extra = '';\n    let output = value.reduce((result, val) => {\n      switch (val.type) {\n        case 'text':\n          {\n            result += val.value;\n            break;\n          }\n        case 'func':\n          {\n            let fname = val.name.substr(1);\n            let fn = this.pick_func(fname);\n            if (typeof fn === 'function') {\n              this.check_uniforms(fname);\n              if (this.is_composable(fname)) {\n                let value = get_value((val.arguments[0] || [])[0]);\n                let temp_arg;\n                if (fname === 'doodle') {\n                  if (/^\\d/.test(value)) {\n                    temp_arg = value;\n                    value = get_value((val.arguments[1] || [])[0]);\n                  }\n                }\n                if (!is_nil(value)) {\n                  switch (fname) {\n                    case 'doodle':\n                      result += this.compose_doodle(this.inject_variables(value, coords.count), temp_arg);\n                      break;\n                    case 'shaders':\n                      result += this.compose_shaders(value, coords);\n                      break;\n                    case 'pattern':\n                      result += this.compose_pattern(value, coords);\n                      break;\n                    case 'canvas':\n                      result += this.compose_canvas(value, val.arguments.slice(1));\n                      break;\n                  }\n                }\n              } else {\n                coords.position = val.position;\n                if (val.variables) {\n                  this.compose_variables(val.variables, coords, contextedVariable);\n                }\n                let args = val.arguments.map(arg => {\n                  return fn.lazy ? function () {\n                    for (var _len4 = arguments.length, extra = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n                      extra[_key4] = arguments[_key4];\n                    }\n                    return _this2.compose_argument(arg, coords, extra, val, contextedVariable);\n                  } : this.compose_argument(arg, coords, [], val, contextedVariable);\n                });\n                let output = this.apply_func(fn, coords, args, fname, contextedVariable);\n                if (!is_nil(output)) {\n                  result += output;\n                  if (output.extra) {\n                    extra = output.extra;\n                  }\n                }\n              }\n            } else {\n              result += val.name;\n            }\n          }\n      }\n      return result;\n    }, '');\n    return {\n      value: output,\n      extra: extra\n    };\n  }\n  add_grid_style(_ref4) {\n    let {\n      fill,\n      clip,\n      rotate,\n      scale,\n      translate,\n      flexRow,\n      flexColumn\n    } = _ref4;\n    if (fill) {\n      this.add_rule(':host', `background-color: ${fill};`);\n    }\n    if (!clip) {\n      this.add_rule(':host', 'contain: none;');\n    }\n    if (rotate) {\n      this.add_rule(':container', `rotate: ${rotate};`);\n    }\n    if (scale) {\n      this.add_rule(':container', `scale: ${scale};`);\n    }\n    if (translate) {\n      this.add_rule(':container', `translate: ${translate};`);\n    }\n    if (flexRow) {\n      this.add_rule(':container', `display: flex;`);\n      this.add_rule('cell', `flex: 1;`);\n    }\n    if (flexColumn) {\n      this.add_rule(':container', `display: flex; flex-direction: column;`);\n      this.add_rule('cell', `flex: 1;`);\n    }\n  }\n  compose_rule(token, _coords, selector) {\n    let coords = Object.assign({}, _coords);\n    let prop = token.property;\n    let extra;\n    if (prop === '@seed') {\n      return '';\n    }\n    let value_group = token.value.reduce((ret, v) => {\n      let composed = this.compose_value(v, coords);\n      if (composed) {\n        if (composed.value) {\n          ret.push(composed.value);\n        }\n        if (composed.extra) {\n          extra = composed.extra;\n        }\n      }\n      return ret;\n    }, []);\n    let value = value_group.join(', ');\n    if (/^animation(\\-name)?$/.test(prop)) {\n      this.props.has_animation = true;\n      if (is_host_selector(selector)) {\n        let prefix = uniform_time[prop];\n        if (prefix && value) {\n          value = prefix + ',' + value;\n        }\n      }\n      if (coords.count > 1) {\n        let {\n          count\n        } = coords;\n        switch (prop) {\n          case 'animation-name':\n            {\n              value = value_group.map(n => this.compose_aname(n, count)).join(', ');\n              break;\n            }\n          case 'animation':\n            {\n              value = value_group.map(n => {\n                let group = (n || '').split(/\\s+/);\n                group[0] = this.compose_aname(group[0], count);\n                return group.join(' ');\n              }).join(', ');\n            }\n        }\n      }\n    }\n    if (prop === 'content') {\n      if (!/[\"']|^none\\s?$|^(var|counter|counters|attr|url)\\(/.test(value)) {\n        value = `'${value}'`;\n      }\n    }\n    if (prop === 'transition') {\n      this.props.has_transition = true;\n    }\n    let rule = `${prop}: ${value};`;\n    rule = prefixer(prop, rule);\n    if (prop === 'clip-path') {\n      // fix clip bug\n      rule += ';overflow: hidden;';\n    }\n    if (prop === 'width' || prop === 'height') {\n      if (!is_special_selector(selector)) {\n        rule += `--internal-cell-${prop}: ${value};`;\n      }\n    }\n    let is_image = /^(background|background\\-image)$/.test(prop) && /\\$\\{(canvas|shader|pattern)/.test(value);\n    if (is_image) {\n      rule += 'background-size: 100% 100%;';\n    }\n    if (/^\\-\\-/.test(prop)) {\n      let key = _coords.count;\n      if (is_parent_selector(selector)) {\n        key = 'container';\n      }\n      if (is_host_selector(selector)) {\n        key = 'host';\n      }\n      if (!this.custom_properties[key]) {\n        this.custom_properties[key] = {};\n      }\n      this.custom_properties[key][prop] = value;\n    }\n    if (/^@/.test(prop) && Property[prop.substr(1)]) {\n      let name = prop.substr(1);\n      let transformed = Property[name](value, {\n        is_special_selector: is_special_selector(selector),\n        grid: coords.grid,\n        max_grid: coords.max_grid,\n        extra\n      });\n      switch (name) {\n        case 'grid':\n          {\n            if (is_host_selector(selector)) {\n              rule = transformed.size || '';\n              this.add_grid_style(transformed);\n            } else {\n              rule = '';\n              if (!this.is_grid_defined) {\n                transformed = Property[name](value, {\n                  is_special_selector: true,\n                  grid: coords.grid,\n                  max_grid: coords.max_grid\n                });\n                this.add_rule(':host', transformed.size || '');\n                this.add_grid_style(transformed);\n              }\n            }\n            this.grid = coords.grid;\n            this.is_grid_defined = true;\n            break;\n          }\n        case 'gap':\n          {\n            rule = '';\n            if (!this.is_gap_defined) {\n              this.add_rule(':container', `gap: ${transformed};`);\n              this.is_gap_defined = true;\n            }\n            break;\n          }\n        case 'content':\n          {\n            rule = '';\n            let key = this.compose_selector(coords);\n            if (transformed !== undefined && !is_pseudo_selecotr(selector) && !is_parent_selector(selector)) {\n              this.content[key] = remove_quotes(String(transformed));\n            }\n            this.content[key] = Func.raw({\n              rules: {\n                doodles: this.doodles\n              }\n            })(this.content[key] || '');\n          }\n        case 'seed':\n          {\n            rule = '';\n            break;\n          }\n        case 'place-cell':\n        case 'place':\n        case 'position':\n        case 'offset':\n          {\n            if (!is_host_selector(selector)) {\n              rule = transformed;\n            }\n            break;\n          }\n        case 'use':\n          {\n            if (token.value.length) {\n              this.compose(coords, token.value);\n            }\n            rule = '';\n            break;\n          }\n        default:\n          {\n            rule = transformed;\n          }\n      }\n    }\n    return rule;\n  }\n  get_raw_value(token) {\n    let raw = token.raw();\n    if (is_nil(raw)) {\n      raw = '';\n    }\n    let [_, ...rest] = raw.split(token.property);\n    // It's not accurate, will be solved after the rewrite of css parser.\n    rest = rest.join(token.property).replace(/^\\s*:\\s*/, '').replace(/[;}<]$/, '').trim().replace(/[;}<]$/, '');\n    return rest;\n  }\n  pre_compose_rule(token, _coords) {\n    let coords = Object.assign({}, _coords);\n    let prop = token.property;\n    switch (prop) {\n      case '@grid':\n        {\n          let value_group = token.value.reduce((ret, v) => {\n            let composed = this.compose_value(v, coords);\n            if (composed && composed.value) ret.push(composed.value);\n            return ret;\n          }, []);\n          let value = value_group.join(', ');\n          let name = prop.substr(1);\n          let transformed = Property[name](value, {\n            max_grid: _coords.max_grid\n          });\n          this.grid = transformed.grid;\n          break;\n        }\n      case '@use':\n        {\n          if (token.value.length) {\n            this.pre_compose(coords, token.value);\n          }\n          break;\n        }\n    }\n  }\n  pre_compose(coords, tokens) {\n    if (is_nil(this.seed)) {\n      // get seed first\n      ;\n      (tokens || this.tokens).forEach(token => {\n        if (token.type === 'rule' && token.property === '@seed') {\n          this.seed = this.get_raw_value(token);\n        }\n        if (token.type === 'pseudo' && is_host_selector(token.selector)) {\n          for (let t of make_array(token.styles)) {\n            if (t.type === 'rule' && t.property === '@seed') {\n              this.seed = this.get_raw_value(t);\n            }\n          }\n        }\n      });\n      if (is_nil(this.seed)) {\n        //this.seed = coords.seed_value;\n      } else {\n        coords.update_random(this.seed);\n      }\n    }\n    ;\n    (tokens || this.tokens).forEach(token => {\n      switch (token.type) {\n        case 'rule':\n          {\n            this.pre_compose_rule(token, coords);\n            break;\n          }\n        case 'pseudo':\n          {\n            if (is_host_selector(token.selector)) {\n              (token.styles || []).forEach(token => {\n                this.pre_compose_rule(token, coords);\n              });\n            }\n            break;\n          }\n      }\n    });\n  }\n  compose(coords, tokens, initial) {\n    this.coords.push(coords);\n    (tokens || this.tokens).forEach((token, i) => {\n      if (token.skip) return false;\n      if (initial && this.grid) return false;\n      switch (token.type) {\n        case 'rule':\n          {\n            this.add_rule(this.compose_selector(coords), this.compose_rule(token, coords));\n            break;\n          }\n        case 'pseudo':\n          {\n            if (token.selector.startsWith(':doodle')) {\n              token.selector = token.selector.replace(/^\\:+doodle/, ':host');\n            }\n            let special = is_special_selector(token.selector);\n            if (special) {\n              token.skip = true;\n            }\n            token.selector.split(',').forEach(selector => {\n              let pseudo = token.styles.map(s => this.compose_rule(s, coords, selector));\n              let composed = special ? selector : this.compose_selector(coords, selector);\n              this.add_rule(composed, pseudo);\n            });\n            break;\n          }\n        case 'cond':\n          {\n            let name = token.name.substr(1);\n            let fn = Selector[name];\n            if (fn) {\n              let args = token.arguments.map(arg => {\n                return this.compose_argument(arg, coords);\n              });\n              let cond = this.apply_func(fn, coords, args, name);\n              if (Array.isArray(token.addition)) {\n                for (let c of token.addition) {\n                  if (c === 'not') cond = !cond;\n                }\n              }\n              if (cond) {\n                if (cond.selector) {\n                  token.styles.forEach(_token => {\n                    if (_token.type === 'rule') {\n                      this.add_rule(cond.selector.replaceAll('$', this.compose_selector(coords)), this.compose_rule(_token, coords));\n                    }\n                    if (_token.type === 'pseudo') {\n                      _token.selector.split(',').forEach(selector => {\n                        let pseudo = _token.styles.map(s => this.compose_rule(s, coords, selector));\n                        this.add_rule((cond.selector + selector).replaceAll('$', this.compose_selector(coords)), pseudo);\n                      });\n                    }\n                  });\n                } else {\n                  this.compose(coords, token.styles);\n                }\n              }\n            }\n            break;\n          }\n        case 'keyframes':\n          {\n            if (!this.keyframes[token.name]) {\n              this.keyframes[token.name] = coords => `\n              ${join(token.steps.map(step => `\n                ${step.name} {\n                  ${join(step.styles.map(s => this.compose_rule(s, coords)))}\n                }\n              `))}\n            `;\n            }\n          }\n      }\n    });\n  }\n  output() {\n    for (let [selector, rule] of Object.entries(this.rules)) {\n      if (is_parent_selector(selector)) {\n        this.styles.container += `\n          .container {\n            ${join(rule)}\n          }\n        `;\n      } else {\n        let target = is_host_selector(selector) ? 'host' : 'cells';\n        let value = join(rule).trim();\n        if (value.length) {\n          let name = target === 'host' ? `${selector}, .host` : selector;\n          this.styles[target] += `${name} { ${value} }`;\n        }\n      }\n    }\n    if (this.uniforms.time) {\n      this.styles.container += `\n        :host, .host {\n          animation: ${uniform_time.animation};\n        }\n      `;\n      this.styles.keyframes += `\n       @keyframes ${uniform_time['animation-name']} {\n         from { --${uniform_time.name}: 0 }\n         to { --${uniform_time.name}: ${uniform_time['animation-duration'] / 10} }\n       }\n      `;\n    }\n    this.coords.forEach((coords, i) => {\n      for (let [name, keyframe] of Object.entries(this.keyframes)) {\n        let aname = this.compose_aname(name, coords.count);\n        this.styles.keyframes += `\n          ${maybe(i === 0, `@keyframes ${name} { ${keyframe(coords)} }`)}\n          @keyframes ${aname} {\n            ${keyframe(coords)}\n          }\n        `;\n      }\n    });\n    return {\n      props: this.props,\n      styles: this.styles,\n      grid: this.grid,\n      seed: this.seed,\n      random: this.random,\n      doodles: this.doodles,\n      shaders: this.shaders,\n      canvas: this.canvas,\n      pattern: this.pattern,\n      uniforms: this.uniforms,\n      content: this.content\n    };\n  }\n}\nfunction remove_quotes(input) {\n  let remove = input.startsWith('\"') && input.endsWith('\"') || input.startsWith(\"'\") && input.endsWith(\"'\");\n  if (remove) {\n    return input.substring(1, input.length - 1);\n  }\n  return input;\n}\nfunction generate_css(tokens, grid_size, seed_value, max_grid, seed_random) {\n  let rules = new Rules(tokens);\n  let random = seed_random || seedrandom(String(seed_value));\n  let context = {};\n  function update_random(seed) {\n    random = seedrandom(String(seed));\n  }\n  function rand() {\n    let start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let end = arguments.length > 1 ? arguments[1] : undefined;\n    if (arguments.length == 1) {\n      [start, end] = [0, start];\n    }\n    return lerp(random(), start, end);\n  }\n  function pick() {\n    for (var _len5 = arguments.length, items = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      items[_key5] = arguments[_key5];\n    }\n    let args = items.reduce((acc, n) => acc.concat(n), []);\n    return args[~~(random() * args.length)];\n  }\n  function shuffle(arr) {\n    let ret = [...arr];\n    let m = arr.length;\n    while (m) {\n      let i = ~~(random() * m--);\n      let t = ret[m];\n      ret[m] = ret[i];\n      ret[i] = t;\n    }\n    return ret;\n  }\n  rules.pre_compose({\n    x: 1,\n    y: 1,\n    z: 1,\n    count: 1,\n    context: {},\n    grid: {\n      x: 1,\n      y: 1,\n      z: 1,\n      count: 1\n    },\n    random,\n    rand,\n    pick,\n    shuffle,\n    max_grid,\n    update_random,\n    seed_value,\n    rules\n  });\n  let {\n    grid,\n    seed\n  } = rules.output();\n  if (grid) {\n    grid_size = grid;\n  }\n  if (seed) {\n    seed = String(seed);\n    random = seedrandom(seed);\n  } else {\n    seed = seed_value;\n  }\n  if (is_nil(seed)) {\n    seed = Date.now();\n    random = seedrandom(seed);\n  }\n  seed = String(seed);\n  rules.seed = seed;\n  rules.random = random;\n  rules.reset();\n  if (grid_size.z == 1) {\n    for (let y = 1, count = 0; y <= grid_size.y; ++y) {\n      for (let x = 1; x <= grid_size.x; ++x) {\n        rules.compose({\n          x,\n          y,\n          z: 1,\n          count: ++count,\n          grid: grid_size,\n          context,\n          rand,\n          pick,\n          shuffle,\n          random,\n          seed,\n          max_grid,\n          rules\n        });\n      }\n    }\n  } else {\n    for (let z = 1, count = 0; z <= grid_size.z; ++z) {\n      rules.compose({\n        x: 1,\n        y: 1,\n        z,\n        count: ++count,\n        grid: grid_size,\n        context,\n        rand,\n        pick,\n        shuffle,\n        random,\n        seed,\n        max_grid,\n        rules\n      });\n    }\n  }\n  return rules.output();\n}\nexport { generate_css };","map":{"version":3,"names":["Func","Property","Selector","parse_value_group","calc","uniform_time","seedrandom","prefixer","maybe","cell_id","is_nil","get_value","lerp","unique_id","join","make_array","remove_empty_values","is_host_selector","s","test","is_parent_selector","is_special_selector","is_pseudo_selecotr","MathFunc","name","Object","getOwnPropertyNames","Math","args","map","n","Rules","constructor","tokens","rules","props","keyframes","grid","seed","is_grid_defined","is_gap_defined","coords","doodles","canvas","pattern","shaders","reset","custom_properties","uniforms","content","styles","host","container","cells","key","startsWith","add_rule","selector","rule","push","apply","pick_func","apply_func","fn","fname","contextedVariable","_fn","input","forEach","arg","type","value","is_string_or_number","cluster","noSpace","group","assign","count","context","unit","entries","substr","length","split","compose_aname","compose_selector","x","y","z","pseudo","is_composable","includes","read_var","undefined","result","String","trim","last","substring","replace","compose_argument","argument","extra","parent","check_uniforms","arguments","temp_arg","val","compose_doodle","inject_variables","compose_shaders","compose_canvas","slice","compose_pattern","position","lazy","pop","doodle","id","shader","cell","code","rest","commands","time","mousex","mousey","width","height","variables","compose_variables","value_group","reduce","ret","v","composed","compose_value","Array","isArray","output","add_grid_style","fill","clip","rotate","scale","translate","flexRow","flexColumn","compose_rule","token","_coords","prop","property","has_animation","prefix","has_transition","is_image","transformed","max_grid","size","remove_quotes","raw","compose","get_raw_value","_","pre_compose_rule","pre_compose","t","update_random","initial","i","skip","special","cond","addition","c","_token","replaceAll","steps","step","target","animation","keyframe","aname","random","remove","endsWith","generate_css","grid_size","seed_value","seed_random","rand","start","end","pick","items","acc","concat","shuffle","arr","m","Date","now"],"sources":["/Users/mariaeduardatc/Documents/GitHub/website/node_modules/css-doodle/src/generator/css.js"],"sourcesContent":["import Func from '../function.js';\nimport Property from '../property.js';\nimport Selector from '../selector.js';\nimport parse_value_group from '../parser/parse-value-group.js';\n\nimport calc from '../calc.js';\nimport { uniform_time } from '../uniforms.js';\nimport { seedrandom } from '../lib/seedrandom.js';\n\nimport { prefixer } from '../utils/prefixer.js';\nimport { maybe, cell_id, is_nil, get_value, lerp, unique_id } from '../utils/index.js';\nimport { join, make_array, remove_empty_values } from '../utils/list.js'\n\nfunction is_host_selector(s) {\n  return /^\\:(host|doodle)/.test(s);\n}\n\nfunction is_parent_selector(s) {\n  return /^\\:(container|parent)/.test(s);\n}\n\nfunction is_special_selector(s) {\n  return is_host_selector(s) || is_parent_selector(s);\n}\n\nfunction is_pseudo_selecotr(s) {\n  return /\\:before|\\:after/.test(s);\n}\n\nconst MathFunc = {};\nfor (let name of Object.getOwnPropertyNames(Math)) {\n  MathFunc[name] = () => (...args) => {\n    if (typeof Math[name] === 'number') {\n      return Math[name];\n    }\n    args = args.map(n => calc(get_value(n)));\n    return Math[name](...args);\n  }\n}\n\nclass Rules {\n\n  constructor(tokens) {\n    this.tokens = tokens;\n    this.rules = {};\n    this.props = {};\n    this.keyframes = {};\n    this.grid = null;\n    this.seed = null;\n    this.is_grid_defined = false;\n    this.is_gap_defined = false;\n    this.coords = [];\n    this.doodles = {};\n    this.canvas = {};\n    this.pattern = {};\n    this.shaders = {};\n    this.reset();\n    this.custom_properties = {};\n    this.uniforms = {};\n    this.content = {};\n  }\n\n  reset() {\n    this.styles = {\n      host: '',\n      container: '',\n      cells: '',\n      keyframes: ''\n    }\n    this.coords = [];\n    this.doodles = {};\n    this.canvas = {};\n    this.pattern = {};\n    this.shaders = {};\n    this.content = {};\n    for (let key in this.rules) {\n      if (key.startsWith('#c')) {\n        delete this.rules[key];\n      }\n    }\n  }\n\n  add_rule(selector, rule) {\n    let rules = this.rules[selector];\n    if (!rules) {\n      rules = this.rules[selector] = [];\n    }\n    rules.push.apply(rules, make_array(rule));\n  }\n\n  pick_func(name) {\n    if (name.startsWith('$')) name = 'calc';\n    return Func[name] || MathFunc[name];\n  }\n\n  apply_func(fn, coords, args, fname, contextedVariable = {}) {\n    let _fn = fn(...make_array(coords));\n    let input = [];\n    args.forEach(arg => {\n      let type = typeof arg.value;\n      let is_string_or_number = (type === 'number' || type === 'string');\n      if (!arg.cluster && (is_string_or_number)) {\n        input.push(...parse_value_group(arg.value, { noSpace: true }));\n      }\n      else {\n        if (typeof arg === 'function') {\n          input.push(arg);\n        }\n        else if (!is_nil(arg.value)) {\n          let value = get_value(arg.value);\n          input.push(value);\n        }\n      }\n    });\n    input = make_array(remove_empty_values(input));\n    if (typeof _fn === 'function') {\n      if (fname.startsWith('$')) {\n        let group = Object.assign({},\n          this.custom_properties['host'],\n          this.custom_properties['container'],\n          this.custom_properties[coords.count],\n          contextedVariable\n        );\n        let context = {};\n        let unit = '';\n        for (let [name, key] of Object.entries(group)) {\n          context[name.substr(2)] = key;\n        }\n        if (fname.length > 1) {\n          unit = fname.split('$')[1] ?? '';\n        }\n        return _fn(input, context) + unit;\n      }\n      return _fn(...input);\n    }\n    return _fn;\n  }\n\n  compose_aname(...args) {\n    return args.join('-');\n  }\n\n  compose_selector({ x, y, z}, pseudo = '') {\n    return `#${ cell_id(x, y, z) }${ pseudo }`;\n  }\n\n  is_composable(name) {\n    return ['doodle', 'shaders', 'canvas', 'pattern'].includes(name);\n  }\n\n  read_var(value, coords, contextedVariable) {\n    let count = coords.count;\n    let group = Object.assign({},\n      this.custom_properties['host'],\n      this.custom_properties['container'],\n      this.custom_properties[count],\n      contextedVariable\n    );\n    if (group[value] !== undefined) {\n      let result = String(group[value]).trim();\n      if (result[0] == '(') {\n        let last = result[result.length - 1];\n        if (last === ')') {\n          result = result.substring(1, result.length - 1);\n        }\n      }\n      return result.replace(/;+$/g, '');\n    }\n    return value;\n  }\n\n  compose_argument(argument, coords, extra = [], parent, contextedVariable) {\n    if (!coords.extra) coords.extra = [];\n    coords.extra.push(extra);\n    let result = argument.map(arg => {\n      if (arg.type === 'text') {\n        if (/^\\-\\-\\w/.test(arg.value)) {\n          if (parent && parent.name === '@var') {\n            return arg.value;\n          }\n          return this.read_var(arg.value, coords, contextedVariable);\n        }\n        return arg.value;\n      }\n      else if (arg.type === 'func') {\n        let fname = arg.name.substr(1);\n        let fn = this.pick_func(fname);\n        if (typeof fn === 'function') {\n          this.check_uniforms(fname);\n          if (this.is_composable(fname)) {\n            let value = get_value((arg.arguments[0] || [])[0]);\n            let temp_arg;\n            if (fname === 'doodle') {\n              if (/^\\d/.test(value)) {\n                temp_arg = value;\n                value = get_value((val.arguments[1] || [])[0]);\n              }\n            }\n            if (!is_nil(value)) {\n              switch (fname) {\n                case 'doodle':\n                  return this.compose_doodle(this.inject_variables(value, coords.count), temp_arg);\n                case 'shaders':\n                  return this.compose_shaders(value, coords);\n                case 'canvas':\n                  return this.compose_canvas(value, arg.arguments.slice(1));\n                case 'pattern':\n                  return this.compose_pattern(value, coords);\n              }\n            }\n          }\n          coords.position = arg.position;\n          let args = arg.arguments.map(n => {\n            return fn.lazy\n              ? (...extra) => this.compose_argument(n, coords, extra, arg, contextedVariable)\n              : this.compose_argument(n, coords, extra, arg, contextedVariable);\n          });\n          return this.apply_func(fn, coords, args, fname, contextedVariable);\n        } else {\n          return arg.name;\n        }\n      }\n    });\n\n    coords.extra.pop();\n\n    return {\n      cluster: argument.cluster,\n      value: (result.length >= 2 ? ({ value: result.join('') }) : result[0])\n    }\n  }\n\n  compose_doodle(doodle, arg) {\n    let id = unique_id('doodle');\n    this.doodles[id] = { doodle, arg };\n    return '${' + id + '}';\n  }\n\n  compose_shaders(shader, {x, y, z}) {\n    let id = unique_id('shader');\n    this.shaders[id] = {\n      id: '--' + id,\n      shader,\n      cell: cell_id(x, y, z)\n    };\n    return '${' + id + '}';\n  }\n\n  compose_pattern(code, {x, y, z}) {\n    let id = unique_id('pattern');\n    this.pattern[id] = {\n      id: '--' + id,\n      code,\n      cell: cell_id(x, y, z)\n    };\n    return '${' + id + '}';\n  }\n\n  compose_canvas(code, rest = []) {\n    let commands = code;\n    let result = rest.map(group => get_value(group[0])).join(',');\n    if (result.length) {\n      commands = code + ',' + result;\n    }\n    let id = unique_id('canvas');\n    this.canvas[id] = { code: commands };\n    return '${' + id + '}';\n  }\n\n  check_uniforms(name) {\n    switch (name) {\n      case 'ut': case 't': this.uniforms.time = true; break;\n      case 'ux': this.uniforms.mousex = true; break;\n      case 'uy': this.uniforms.mousey = true; break;\n      case 'uw': this.uniforms.width = true; break;\n      case 'uh': this.uniforms.height = true; break;\n    }\n  }\n\n  inject_variables(value, count) {\n    let group = Object.assign({},\n      this.custom_properties['host'],\n      this.custom_properties['container'],\n      this.custom_properties[count]\n    );\n    let variables = [];\n    for (let [name, key] of Object.entries(group)) {\n      variables.push(`${name}: ${key};`);\n    }\n    variables = variables.join('');\n    if (variables.length) {\n      return `:doodle { ${variables} }` + value;\n    }\n    return value;\n  }\n\n  compose_variables(variables, coords, result = {}) {\n    for (let [name, value] of Object.entries(variables)) {\n      let value_group = value.reduce((ret, v) => {\n        let composed = this.compose_value(v, coords, result);\n        if (composed && composed.value) {\n          ret.push(composed.value);\n        }\n        return ret;\n      }, []);\n      result[name] = value_group.join(', ');\n    }\n    return result;\n  }\n\n  compose_value(value, coords, contextedVariable = {}) {\n    if (!Array.isArray(value)) {\n      return {\n        value: '',\n        extra: '',\n      }\n    }\n    let extra = '';\n    let output = value.reduce((result, val) => {\n      switch (val.type) {\n        case 'text': {\n          result += val.value;\n          break;\n        }\n        case 'func': {\n          let fname = val.name.substr(1);\n          let fn = this.pick_func(fname);\n          if (typeof fn === 'function') {\n            this.check_uniforms(fname);\n            if (this.is_composable(fname)) {\n              let value = get_value((val.arguments[0] || [])[0]);\n              let temp_arg;\n              if (fname === 'doodle') {\n                if (/^\\d/.test(value)) {\n                  temp_arg = value;\n                  value = get_value((val.arguments[1] || [])[0]);\n                }\n              }\n              if (!is_nil(value)) {\n                switch (fname) {\n                  case 'doodle':\n                    result += this.compose_doodle(this.inject_variables(value, coords.count), temp_arg); break;\n                  case 'shaders':\n                    result += this.compose_shaders(value, coords); break;\n                  case 'pattern':\n                    result += this.compose_pattern(value, coords); break;\n                  case 'canvas':\n                    result += this.compose_canvas(value, val.arguments.slice(1)); break;\n                }\n              }\n            } else {\n              coords.position = val.position;\n              if (val.variables) {\n                this.compose_variables(val.variables, coords, contextedVariable);\n              }\n              let args = val.arguments.map(arg => {\n                return fn.lazy\n                  ? (...extra) => this.compose_argument(arg, coords, extra, val, contextedVariable)\n                  : this.compose_argument(arg, coords, [], val, contextedVariable);\n              });\n\n              let output = this.apply_func(fn, coords, args, fname, contextedVariable);\n              if (!is_nil(output)) {\n                result += output;\n                if (output.extra) {\n                  extra = output.extra;\n                }\n              }\n            }\n          } else {\n            result += val.name;\n          }\n        }\n      }\n      return result;\n    }, '');\n\n    return {\n      value: output,\n      extra: extra,\n    }\n  }\n\n  add_grid_style({ fill, clip, rotate, scale, translate, flexRow, flexColumn }) {\n    if (fill) {\n      this.add_rule(':host', `background-color: ${fill};`);\n    }\n    if (!clip) {\n      this.add_rule(':host', 'contain: none;');\n    }\n    if (rotate) {\n      this.add_rule(':container', `rotate: ${rotate};`);\n    }\n    if (scale) {\n      this.add_rule(':container', `scale: ${scale};`);\n    }\n    if (translate) {\n      this.add_rule(':container', `translate: ${translate};`);\n    }\n    if (flexRow) {\n      this.add_rule(':container', `display: flex;`);\n      this.add_rule('cell', `flex: 1;`);\n    }\n    if (flexColumn) {\n      this.add_rule(':container', `display: flex; flex-direction: column;`);\n      this.add_rule('cell', `flex: 1;`);\n    }\n  }\n\n  compose_rule(token, _coords, selector) {\n    let coords = Object.assign({}, _coords);\n    let prop = token.property;\n    let extra;\n    if (prop === '@seed') {\n      return '';\n    }\n    let value_group = token.value.reduce((ret, v) => {\n      let composed = this.compose_value(v, coords);\n      if (composed) {\n        if (composed.value) {\n          ret.push(composed.value);\n        }\n        if (composed.extra) {\n          extra = composed.extra;\n        }\n      }\n      return ret;\n    }, []);\n\n    let value = value_group.join(', ');\n\n    if (/^animation(\\-name)?$/.test(prop)) {\n      this.props.has_animation = true;\n\n      if (is_host_selector(selector)) {\n        let prefix = uniform_time[prop];\n        if (prefix && value) {\n          value =  prefix + ',' + value;\n        }\n      }\n\n      if (coords.count > 1) {\n        let { count } = coords;\n        switch (prop) {\n          case 'animation-name': {\n            value = value_group\n              .map(n => this.compose_aname(n, count))\n              .join(', ');\n            break;\n          }\n          case 'animation': {\n            value = value_group\n              .map(n => {\n                let group = (n || '').split(/\\s+/);\n                group[0] = this.compose_aname(group[0], count);\n                return group.join(' ');\n              })\n              .join(', ');\n          }\n        }\n      }\n    }\n\n    if (prop === 'content') {\n      if (!/[\"']|^none\\s?$|^(var|counter|counters|attr|url)\\(/.test(value)) {\n        value = `'${ value }'`;\n      }\n    }\n\n    if (prop === 'transition') {\n      this.props.has_transition = true;\n    }\n\n    let rule = `${ prop }: ${ value };`\n    rule = prefixer(prop, rule);\n\n    if (prop === 'clip-path') {\n      // fix clip bug\n      rule += ';overflow: hidden;';\n    }\n\n    if (prop === 'width' || prop === 'height') {\n      if (!is_special_selector(selector)) {\n        rule += `--internal-cell-${ prop }: ${ value };`;\n      }\n    }\n\n    let is_image = (\n      /^(background|background\\-image)$/.test(prop) &&\n      /\\$\\{(canvas|shader|pattern)/.test(value)\n    );\n    if (is_image) {\n      rule += 'background-size: 100% 100%;';\n    }\n\n    if (/^\\-\\-/.test(prop)) {\n      let key = _coords.count;\n      if (is_parent_selector(selector)) {\n        key = 'container';\n      }\n      if (is_host_selector(selector)) {\n        key = 'host';\n      }\n      if (!this.custom_properties[key]) {\n        this.custom_properties[key] = {};\n      }\n      this.custom_properties[key][prop] = value;\n    }\n\n    if (/^@/.test(prop) && Property[prop.substr(1)]) {\n      let name = prop.substr(1);\n      let transformed = Property[name](value, {\n        is_special_selector: is_special_selector(selector),\n        grid: coords.grid,\n        max_grid: coords.max_grid,\n        extra\n      });\n      switch (name) {\n        case 'grid': {\n          if (is_host_selector(selector)) {\n            rule = transformed.size || '';\n            this.add_grid_style(transformed);\n          } else {\n            rule = '';\n            if (!this.is_grid_defined) {\n              transformed = Property[name](value, {\n                is_special_selector: true,\n                grid: coords.grid,\n                max_grid: coords.max_grid\n              });\n              this.add_rule(':host', transformed.size || '');\n              this.add_grid_style(transformed);\n            }\n          }\n          this.grid = coords.grid;\n          this.is_grid_defined = true;\n          break;\n        }\n        case 'gap': {\n          rule = '';\n          if (!this.is_gap_defined) {\n            this.add_rule(':container', `gap: ${transformed};`);\n            this.is_gap_defined = true;\n          }\n          break;\n        }\n        case 'content': {\n          rule = '';\n          let key = this.compose_selector(coords);\n          if (transformed !== undefined && !is_pseudo_selecotr(selector) && !is_parent_selector(selector)) {\n            this.content[key] = remove_quotes(String(transformed));\n          }\n          this.content[key] = Func.raw({\n            rules: {\n              doodles: this.doodles\n            }\n          })(this.content[key] || '');\n        }\n        case 'seed': {\n          rule = '';\n          break;\n        }\n        case 'place-cell':\n        case 'place':\n        case 'position':\n        case 'offset': {\n          if (!is_host_selector(selector)) {\n            rule = transformed;\n          }\n          break;\n        }\n        case 'use': {\n          if (token.value.length) {\n            this.compose(coords, token.value);\n          }\n          rule = '';\n          break;\n        }\n        default: {\n          rule = transformed;\n        }\n      }\n    }\n\n    return rule;\n  }\n\n  get_raw_value(token) {\n    let raw = token.raw();\n    if (is_nil(raw)){\n      raw = '';\n    }\n    let [_, ...rest] = raw.split(token.property);\n    // It's not accurate, will be solved after the rewrite of css parser.\n    rest = rest.join(token.property)\n      .replace(/^\\s*:\\s*/, '')\n      .replace(/[;}<]$/, '').trim()\n      .replace(/[;}<]$/, '');\n    return rest;\n  }\n\n  pre_compose_rule(token, _coords) {\n    let coords = Object.assign({}, _coords);\n    let prop = token.property;\n\n    switch (prop) {\n      case '@grid': {\n        let value_group = token.value.reduce((ret, v) => {\n          let composed = this.compose_value(v, coords);\n          if (composed && composed.value) ret.push(composed.value);\n          return ret;\n        }, []);\n        let value = value_group.join(', ');\n        let name = prop.substr(1);\n        let transformed = Property[name](value, {\n          max_grid: _coords.max_grid\n        });\n        this.grid = transformed.grid;\n        break;\n      }\n      case '@use': {\n        if (token.value.length) {\n          this.pre_compose(coords, token.value);\n        }\n        break;\n      }\n    }\n  }\n\n  pre_compose(coords, tokens) {\n    if (is_nil(this.seed)) {\n      // get seed first\n      ;(tokens || this.tokens).forEach(token => {\n        if (token.type === 'rule' && token.property === '@seed') {\n          this.seed = this.get_raw_value(token);\n        }\n        if (token.type === 'pseudo' && is_host_selector(token.selector)) {\n          for (let t of make_array(token.styles)) {\n            if (t.type === 'rule' && t.property === '@seed') {\n              this.seed = this.get_raw_value(t);\n            }\n          }\n        }\n      });\n      if (is_nil(this.seed)) {\n        //this.seed = coords.seed_value;\n      } else {\n        coords.update_random(this.seed);\n      }\n    }\n    ;(tokens || this.tokens).forEach(token => {\n      switch (token.type) {\n        case 'rule': {\n          this.pre_compose_rule(token, coords)\n          break;\n        }\n        case 'pseudo': {\n          if (is_host_selector(token.selector)) {\n            (token.styles || []).forEach(token => {\n              this.pre_compose_rule(token, coords);\n            });\n          }\n          break;\n        }\n      }\n    });\n  }\n\n  compose(coords, tokens, initial) {\n    this.coords.push(coords);\n    (tokens || this.tokens).forEach((token, i) => {\n      if (token.skip) return false;\n      if (initial && this.grid) return false;\n\n      switch (token.type) {\n        case 'rule': {\n          this.add_rule(\n            this.compose_selector(coords),\n            this.compose_rule(token, coords)\n          );\n          break;\n        }\n\n        case 'pseudo': {\n          if (token.selector.startsWith(':doodle')) {\n            token.selector = token.selector.replace(/^\\:+doodle/, ':host');\n          }\n          let special = is_special_selector(token.selector);\n          if (special) {\n            token.skip = true;\n          }\n          token.selector.split(',').forEach(selector => {\n            let pseudo = token.styles.map(s =>\n              this.compose_rule(s, coords, selector)\n            );\n            let composed = special\n              ? selector\n              : this.compose_selector(coords, selector);\n            this.add_rule(composed, pseudo);\n          });\n\n          break;\n        }\n\n        case 'cond': {\n          let name = token.name.substr(1);\n          let fn = Selector[name];\n          if (fn) {\n            let args = token.arguments.map(arg => {\n              return this.compose_argument(arg, coords);\n            });\n            let cond = this.apply_func(fn, coords, args, name);\n            if (Array.isArray(token.addition)) {\n              for (let c of token.addition) {\n                if (c === 'not') cond = !cond;\n              }\n            }\n            if (cond) {\n              if (cond.selector) {\n                token.styles.forEach(_token => {\n                  if (_token.type === 'rule') {\n                    this.add_rule(\n                      cond.selector.replaceAll('$', this.compose_selector(coords)),\n                      this.compose_rule(_token, coords)\n                    )\n                  }\n                  if (_token.type === 'pseudo') {\n                    _token.selector.split(',').forEach(selector => {\n                      let pseudo = _token.styles.map(s =>\n                        this.compose_rule(s, coords, selector)\n                      );\n                      this.add_rule(\n                        (cond.selector + selector).replaceAll('$', this.compose_selector(coords)),\n                        pseudo\n                      );\n                    });\n                  }\n                });\n              } else {\n                this.compose(coords, token.styles);\n              }\n            }\n          }\n          break;\n        }\n\n        case 'keyframes': {\n          if (!this.keyframes[token.name]) {\n            this.keyframes[token.name] = coords => `\n              ${ join(token.steps.map(step => `\n                ${ step.name } {\n                  ${ join(\n                    step.styles.map(s => this.compose_rule(s, coords))\n                  )}\n                }\n              `)) }\n            `;\n          }\n        }\n      }\n    });\n  }\n\n  output() {\n    for (let [selector, rule] of Object.entries(this.rules)) {\n      if (is_parent_selector(selector)) {\n        this.styles.container += `\n          .container {\n            ${ join(rule) }\n          }\n        `;\n      } else {\n        let target = is_host_selector(selector) ? 'host' : 'cells';\n        let value = join(rule).trim();\n        if (value.length) {\n          let name = (target === 'host') ? `${ selector }, .host` : selector;\n          this.styles[target] += `${ name } { ${ value  } }`;\n        }\n      }\n    }\n\n    if (this.uniforms.time) {\n      this.styles.container += `\n        :host, .host {\n          animation: ${ uniform_time.animation };\n        }\n      `;\n      this.styles.keyframes += `\n       @keyframes ${ uniform_time['animation-name'] } {\n         from { --${ uniform_time.name }: 0 }\n         to { --${ uniform_time.name }: ${ uniform_time['animation-duration'] / 10 } }\n       }\n      `;\n    }\n\n    this.coords.forEach((coords, i) => {\n      for (let [name, keyframe] of Object.entries(this.keyframes)) {\n        let aname = this.compose_aname(name, coords.count);\n        this.styles.keyframes += `\n          ${ maybe(i === 0, `@keyframes ${ name } { ${ keyframe(coords) } }`)}\n          @keyframes ${ aname } {\n            ${ keyframe(coords) }\n          }\n        `;\n      }\n    });\n\n    return {\n      props: this.props,\n      styles: this.styles,\n      grid: this.grid,\n      seed: this.seed,\n      random: this.random,\n      doodles: this.doodles,\n      shaders: this.shaders,\n      canvas: this.canvas,\n      pattern: this.pattern,\n      uniforms: this.uniforms,\n      content: this.content,\n    }\n  }\n\n}\n\nfunction remove_quotes(input) {\n  let remove = (input.startsWith('\"') && input.endsWith('\"'))\n    || (input.startsWith(\"'\") && input.endsWith(\"'\"));\n  if (remove) {\n    return input.substring(1, input.length - 1);\n  }\n  return input;\n}\n\nfunction generate_css(tokens, grid_size, seed_value, max_grid, seed_random) {\n  let rules = new Rules(tokens);\n  let random = seed_random || seedrandom(String(seed_value));\n  let context = {};\n\n  function update_random(seed) {\n    random = seedrandom(String(seed));\n  }\n\n  function rand(start = 0, end) {\n    if (arguments.length == 1) {\n      [start, end] = [0, start];\n    }\n    return lerp(random(), start, end);\n  }\n\n  function pick(...items) {\n    let args = items.reduce((acc, n) => acc.concat(n), []);\n    return args[~~(random() * args.length)];\n  }\n\n  function shuffle(arr) {\n    let ret = [...arr];\n    let m = arr.length;\n    while (m) {\n      let i = ~~(random() * m--);\n      let t = ret[m];\n      ret[m] = ret[i];\n      ret[i] = t;\n    }\n    return ret;\n  }\n\n  rules.pre_compose({\n    x: 1, y: 1, z: 1, count: 1, context: {},\n    grid: { x: 1, y: 1, z: 1, count: 1 },\n    random, rand, pick, shuffle,\n    max_grid, update_random,\n    seed_value,\n    rules,\n  });\n\n  let { grid, seed } = rules.output();\n\n  if (grid) {\n    grid_size = grid;\n  }\n\n  if (seed) {\n    seed = String(seed);\n    random = seedrandom(seed);\n  } else {\n    seed = seed_value;\n  }\n\n  if (is_nil(seed)) {\n    seed = Date.now();\n    random = seedrandom(seed);\n  }\n\n  seed = String(seed);\n  rules.seed = seed;\n  rules.random = random;\n  rules.reset();\n\n  if (grid_size.z == 1) {\n    for (let y = 1, count = 0; y <= grid_size.y; ++y) {\n      for (let x = 1; x <= grid_size.x; ++x) {\n        rules.compose({\n          x, y, z: 1,\n          count: ++count, grid: grid_size, context,\n          rand, pick, shuffle,\n          random, seed,\n          max_grid,\n          rules,\n        });\n      }\n    }\n  }\n  else {\n    for (let z = 1, count = 0; z <= grid_size.z; ++z) {\n      rules.compose({\n        x: 1, y: 1, z,\n        count: ++count, grid: grid_size, context,\n        rand, pick, shuffle,\n        random, seed,\n        max_grid,\n        rules,\n      });\n    }\n  }\n\n  return rules.output();\n}\n\nexport {\n  generate_css,\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}