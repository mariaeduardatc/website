{"ast":null,"code":"/**\n * Based on the Shunting-yard algorithm.\n */\n\nimport { last } from './utils/list.js';\nimport { is_invalid_number } from './utils/index.js';\nconst cache = new Map();\nconst default_context = {\n  'π': Math.PI,\n  gcd: (a, b) => {\n    while (b) [a, b] = [b, a % b];\n    return a;\n  }\n};\nconst operator = {\n  '^': 7,\n  '*': 6,\n  '/': 6,\n  '÷': 6,\n  '%': 6,\n  '&': 5,\n  '|': 5,\n  '+': 4,\n  '-': 4,\n  '<': 3,\n  '<<': 3,\n  '>': 3,\n  '>>': 3,\n  '=': 3,\n  '==': 3,\n  '≤': 3,\n  '<=': 3,\n  '≥': 3,\n  '>=': 3,\n  '≠': 3,\n  '!=': 3,\n  '∧': 2,\n  '&&': 2,\n  '∨': 2,\n  '||': 2,\n  '(': 1,\n  ')': 1\n};\nfunction calc(expr, context) {\n  let repeat = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  let stack = [];\n  while (expr.length) {\n    let {\n      name,\n      value,\n      type\n    } = expr.shift();\n    if (type === 'variable') {\n      let result = context[value];\n      if (is_invalid_number(result)) {\n        result = Math[value];\n      }\n      if (is_invalid_number(result)) {\n        result = expand(value, context, repeat);\n      }\n      if (is_invalid_number(result)) {\n        if (/^\\-\\D/.test(value)) {\n          result = expand('-1' + value.substr(1), context, repeat);\n        }\n      }\n      if (result === undefined) {\n        result = 0;\n      }\n      if (typeof result !== 'number') {\n        repeat.push(result);\n        if (is_cycle(repeat)) {\n          result = 0;\n          repeat = [];\n        } else {\n          result = calc(infix_to_postfix(result), context, repeat);\n        }\n      }\n      stack.push(result);\n    } else if (type === 'function') {\n      let negative = false;\n      if (/^\\-/.test(name)) {\n        negative = true;\n        name = name.substr(1);\n      }\n      let output = value.map(v => calc(v, context, repeat));\n      let fns = name.split('.');\n      let fname;\n      while (fname = fns.pop()) {\n        if (!fname) continue;\n        let fn = context[fname] || Math[fname];\n        output = typeof fn === 'function' ? Array.isArray(output) ? fn(...output) : fn(output) : 0;\n      }\n      if (negative) {\n        output = -1 * output;\n      }\n      stack.push(output);\n    } else {\n      if (/\\d+/.test(value)) stack.push(value);else {\n        let right = stack.pop();\n        let left = stack.pop();\n        stack.push(compute(value, Number(left), Number(right)));\n      }\n    }\n  }\n  return Number(stack[0]) || 0;\n}\nfunction get_tokens(input) {\n  if (cache.has(input)) {\n    return cache.get(input);\n  }\n  let expr = String(input);\n  let tokens = [],\n    num = '';\n  for (let i = 0; i < expr.length; ++i) {\n    let c = expr[i];\n    if (operator[c]) {\n      let last_token = last(tokens);\n      if (c == '=' && last_token && /^[!<>=]$/.test(last_token.value)) {\n        last_token.value += c;\n      } else if (/^[|&<>]$/.test(c) && last_token && last_token.value == c) {\n        last_token.value += c;\n      } else if (c == '-' && expr[i - 1] == 'e') {\n        num += c;\n      } else if (!tokens.length && !num.length && /[+-]/.test(c)) {\n        num += c;\n      } else {\n        let {\n          type,\n          value\n        } = last_token || {};\n        if (type == 'operator' && !num.length && /[^()]/.test(c) && /[^()]/.test(value)) {\n          num += c;\n        } else {\n          if (num.length) {\n            tokens.push({\n              type: 'number',\n              value: num\n            });\n            num = '';\n          }\n          tokens.push({\n            type: 'operator',\n            value: c\n          });\n        }\n      }\n    } else if (/\\S/.test(c)) {\n      if (c == ',') {\n        tokens.push({\n          type: 'number',\n          value: num\n        });\n        num = '';\n        tokens.push({\n          type: 'comma',\n          value: c\n        });\n      } else if (c == '!') {\n        tokens.push({\n          type: 'number',\n          value: num\n        });\n        tokens.push({\n          type: 'operator',\n          value: c\n        });\n        num = '';\n      } else {\n        num += c;\n      }\n    }\n  }\n  if (num.length) {\n    tokens.push({\n      type: 'number',\n      value: num\n    });\n  }\n  cache.set(input, tokens);\n  return tokens;\n}\nfunction infix_to_postfix(input) {\n  let tokens = get_tokens(input);\n  const op_stack = [],\n    expr = [];\n  for (let i = 0; i < tokens.length; ++i) {\n    let {\n      type,\n      value\n    } = tokens[i];\n    let next = tokens[i + 1] || {};\n    if (type == 'number') {\n      if (next.value == '(' && /[^\\d.\\-]/.test(value)) {\n        let func_body = '';\n        let stack = [];\n        let values = [];\n        i += 1;\n        while (tokens[i++] !== undefined) {\n          let token = tokens[i];\n          if (token === undefined) break;\n          let c = token.value;\n          if (c == ')') {\n            if (!stack.length) break;\n            stack.pop();\n            func_body += c;\n          } else {\n            if (c == '(') stack.push(c);\n            if (c == ',' && !stack.length) {\n              let arg = infix_to_postfix(func_body);\n              if (arg.length) values.push(arg);\n              func_body = '';\n            } else {\n              func_body += c;\n            }\n          }\n        }\n        if (func_body.length) {\n          values.push(infix_to_postfix(func_body));\n        }\n        expr.push({\n          type: 'function',\n          name: value,\n          value: values\n        });\n      } else if (/[^\\d.\\-]/.test(value)) {\n        expr.push({\n          type: 'variable',\n          value\n        });\n      } else {\n        expr.push({\n          type: 'number',\n          value\n        });\n      }\n    } else if (type == 'operator') {\n      if (value == '(') {\n        op_stack.push(value);\n      } else if (value == ')') {\n        while (op_stack.length && last(op_stack) != '(') {\n          expr.push({\n            type: 'operator',\n            value: op_stack.pop()\n          });\n        }\n        op_stack.pop();\n      } else {\n        while (op_stack.length && operator[last(op_stack)] >= operator[value]) {\n          let op = op_stack.pop();\n          if (!/[()]/.test(op)) expr.push({\n            type: 'operator',\n            value: op\n          });\n        }\n        op_stack.push(value);\n      }\n    }\n  }\n  while (op_stack.length) {\n    expr.push({\n      type: 'operator',\n      value: op_stack.pop()\n    });\n  }\n  return expr;\n}\nfunction compute(op, a, b) {\n  switch (op) {\n    case '+':\n      return a + b;\n    case '-':\n      return a - b;\n    case '*':\n      return a * b;\n    case '%':\n      return a % b;\n    case '|':\n      return a | b;\n    case '&':\n      return a & b;\n    case '<':\n      return a < b;\n    case '>':\n      return a > b;\n    case '^':\n      return Math.pow(a, b);\n    case '÷':\n    case '/':\n      return a / b;\n    case '=':\n    case '==':\n      return a == b;\n    case '≤':\n    case '<=':\n      return a <= b;\n    case '≥':\n    case '>=':\n      return a >= b;\n    case '≠':\n    case '!=':\n      return a != b;\n    case '∧':\n    case '&&':\n      return a && b;\n    case '∨':\n    case '||':\n      return a || b;\n    case '<<':\n      return a << b;\n    case '>>':\n      return a >> b;\n  }\n}\nfunction expand(value, context, repeat) {\n  let [_, num, variable] = value.match(/([\\d.\\-]+)(.*)/) || [];\n  let v = context[variable];\n  if (v === undefined) {\n    return v;\n  }\n  if (typeof v === 'number') {\n    return Number(num) * v;\n  } else {\n    repeat.push(v);\n    if (is_cycle(repeat)) {\n      repeat = [];\n      return 0;\n    } else {\n      return num * calc(infix_to_postfix(v), context, repeat);\n    }\n  }\n}\nfunction is_cycle(array) {\n  if (array.length > 50) return true;\n  let tail = last(array);\n  for (let i = 2; i <= 4; ++i) {\n    let item = array[array.length - i];\n    if (item === undefined) return false;\n    if (tail !== item) return false;\n  }\n  return true;\n}\nexport default function (input, context) {\n  const expr = infix_to_postfix(input);\n  return calc(expr, Object.assign({}, default_context, context));\n}","map":{"version":3,"names":["last","is_invalid_number","cache","Map","default_context","Math","PI","gcd","a","b","operator","calc","expr","context","repeat","stack","length","name","value","type","shift","result","expand","test","substr","undefined","push","is_cycle","infix_to_postfix","negative","output","map","v","fns","split","fname","pop","fn","Array","isArray","right","left","compute","Number","get_tokens","input","has","get","String","tokens","num","i","c","last_token","set","op_stack","next","func_body","values","token","arg","op","pow","_","variable","match","array","tail","item","Object","assign"],"sources":["/Users/mariaeduardatc/Documents/GitHub/website/node_modules/css-doodle/src/calc.js"],"sourcesContent":["/**\n * Based on the Shunting-yard algorithm.\n */\n\nimport { last } from './utils/list.js';\nimport { is_invalid_number } from './utils/index.js';\n\nconst cache = new Map();\n\nconst default_context = {\n  'π': Math.PI,\n  gcd: (a, b) => {\n    while (b) [a, b] = [b, a % b];\n    return a;\n  }\n}\n\nconst operator = {\n  '^': 7,\n  '*': 6, '/': 6, '÷': 6, '%': 6,\n  '&': 5, '|': 5,\n  '+': 4, '-': 4,\n  '<': 3, '<<': 3,\n  '>': 3, '>>': 3,\n  '=': 3, '==': 3,\n  '≤': 3, '<=': 3,\n  '≥': 3, '>=': 3,\n  '≠': 3, '!=': 3,\n  '∧': 2, '&&': 2,\n  '∨': 2, '||': 2,\n  '(': 1 , ')': 1,\n}\n\nfunction calc(expr, context, repeat = []) {\n  let stack = [];\n  while (expr.length) {\n    let { name, value, type } = expr.shift();\n    if (type === 'variable') {\n      let result = context[value];\n      if (is_invalid_number(result)) {\n        result = Math[value];\n      }\n      if (is_invalid_number(result)) {\n        result = expand(value, context, repeat);\n      }\n      if (is_invalid_number(result)) {\n        if (/^\\-\\D/.test(value)) {\n          result = expand('-1' + value.substr(1), context, repeat);\n        }\n      }\n      if (result === undefined) {\n        result = 0;\n      }\n      if (typeof result !== 'number') {\n        repeat.push(result);\n        if (is_cycle(repeat)) {\n          result = 0;\n          repeat = [];\n        } else {\n          result = calc(infix_to_postfix(result), context, repeat)\n        }\n      }\n      stack.push(result);\n    }\n    else if (type === 'function') {\n      let negative = false;\n      if (/^\\-/.test(name)) {\n        negative = true;\n        name = name.substr(1);\n      }\n      let output = value.map(v => calc(v, context, repeat));\n      let fns = name.split('.');\n      let fname;\n      while (fname = fns.pop()) {\n        if (!fname) continue;\n        let fn = context[fname] || Math[fname];\n        output = (typeof fn === 'function')\n          ? (Array.isArray(output) ? fn(...output) : fn(output))\n          : 0;\n      }\n      if (negative) {\n        output = -1 * output;\n      }\n      stack.push(output);\n    } else {\n      if (/\\d+/.test(value)) stack.push(value);\n      else {\n        let right = stack.pop();\n        let left = stack.pop();\n        stack.push(compute(\n          value, Number(left), Number(right)\n        ));\n      }\n    }\n  }\n  return Number(stack[0]) || 0;\n}\n\nfunction get_tokens(input) {\n  if (cache.has(input)) {\n    return cache.get(input);\n  }\n  let expr = String(input);\n  let tokens = [], num = '';\n\n  for (let i = 0; i < expr.length; ++i) {\n    let c = expr[i];\n    if (operator[c]) {\n      let last_token = last(tokens);\n      if (c == '=' && last_token && /^[!<>=]$/.test(last_token.value)) {\n        last_token.value += c;\n      }\n      else if (/^[|&<>]$/.test(c) && last_token && last_token.value == c) {\n        last_token.value += c;\n      }\n      else if (c == '-' && expr[i - 1] == 'e') {\n        num += c;\n      }\n      else if (!tokens.length && !num.length && /[+-]/.test(c)) {\n        num += c;\n      } else {\n        let { type, value } = last_token || {};\n        if (type == 'operator'\n            && !num.length\n            && /[^()]/.test(c)\n            && /[^()]/.test(value)) {\n          num += c;\n        } else {\n          if (num.length) {\n            tokens.push({ type: 'number', value: num });\n            num = '';\n          }\n          tokens.push({ type: 'operator', value: c });\n        }\n      }\n    }\n    else if (/\\S/.test(c)) {\n      if (c == ',') {\n        tokens.push({ type: 'number', value: num });\n        num = '';\n        tokens.push({ type: 'comma', value: c });\n      } else if (c == '!') {\n        tokens.push({ type: 'number', value: num });\n        tokens.push({ type: 'operator', value: c });\n        num = '';\n      } else {\n        num += c;\n      }\n    }\n  }\n\n  if (num.length) {\n    tokens.push({ type: 'number', value: num });\n  }\n  cache.set(input, tokens);\n  return tokens;\n}\n\nfunction infix_to_postfix(input) {\n  let tokens = get_tokens(input);\n  const op_stack = [], expr = [];\n\n  for (let i = 0; i < tokens.length; ++i) {\n    let { type, value } = tokens[i];\n    let next = tokens[i + 1] || {};\n    if (type == 'number') {\n      if (next.value == '(' && /[^\\d.\\-]/.test(value)) {\n        let func_body = '';\n        let stack = [];\n        let values = [];\n\n        i += 1;\n        while (tokens[i++] !== undefined) {\n          let token = tokens[i];\n          if (token === undefined) break;\n          let c = token.value;\n          if (c == ')') {\n            if (!stack.length) break;\n            stack.pop();\n            func_body += c;\n          }\n          else {\n            if (c == '(') stack.push(c);\n            if (c == ',' && !stack.length) {\n              let arg = infix_to_postfix(func_body);\n              if (arg.length) values.push(arg);\n              func_body = '';\n            } else {\n              func_body += c;\n            }\n          }\n        }\n\n        if (func_body.length) {\n          values.push(infix_to_postfix(func_body));\n        }\n\n        expr.push({\n          type: 'function',\n          name: value,\n          value: values\n        });\n      }\n      else if (/[^\\d.\\-]/.test(value)) {\n        expr.push({ type: 'variable', value });\n      }\n      else {\n        expr.push({ type: 'number', value });\n      }\n    }\n\n    else if (type == 'operator') {\n      if (value == '(') {\n        op_stack.push(value);\n      }\n\n      else if (value == ')') {\n        while (op_stack.length && last(op_stack) != '(') {\n          expr.push({ type: 'operator', value: op_stack.pop() });\n        }\n        op_stack.pop();\n      }\n\n      else {\n        while (op_stack.length && operator[last(op_stack)] >= operator[value]) {\n          let op = op_stack.pop();\n          if (!/[()]/.test(op)) expr.push({ type: 'operator', value: op });\n        }\n        op_stack.push(value);\n      }\n    }\n  }\n\n  while (op_stack.length) {\n    expr.push({ type: 'operator', value: op_stack.pop() });\n  }\n\n  return expr;\n}\n\nfunction compute(op, a, b) {\n  switch (op) {\n    case '+': return a + b;\n    case '-': return a - b;\n    case '*': return a * b;\n    case '%': return a % b;\n    case '|': return a | b;\n    case '&': return a & b;\n    case '<': return a < b;\n    case '>': return a > b;\n    case '^': return Math.pow(a, b);\n    case '÷': case '/': return a / b;\n    case '=': case '==': return a == b;\n    case '≤': case '<=': return a <= b;\n    case '≥': case '>=': return a >= b;\n    case '≠': case '!=': return a != b;\n    case '∧': case '&&': return a && b;\n    case '∨': case '||': return a || b;\n    case '<<': return a << b;\n    case '>>': return a >> b;\n  }\n}\n\nfunction expand(value, context, repeat) {\n  let [_, num, variable] = value.match(/([\\d.\\-]+)(.*)/) || [];\n  let v = context[variable];\n  if (v === undefined) {\n    return v;\n  }\n  if (typeof v === 'number') {\n    return Number(num) * v;\n  } else {\n    repeat.push(v);\n    if (is_cycle(repeat)) {\n      repeat = [];\n      return 0;\n    } else {\n      return num * calc(infix_to_postfix(v), context, repeat);\n    }\n  }\n}\n\nfunction is_cycle(array) {\n  if (array.length > 50) return true;\n  let tail = last(array);\n  for (let i = 2; i <= 4; ++i) {\n    let item = array[array.length - i];\n    if (item === undefined) return false;\n    if (tail !== item) return false;\n  }\n  return true;\n}\n\nexport default function(input, context) {\n  const expr = infix_to_postfix(input);\n  return calc(expr, Object.assign({}, default_context, context));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}