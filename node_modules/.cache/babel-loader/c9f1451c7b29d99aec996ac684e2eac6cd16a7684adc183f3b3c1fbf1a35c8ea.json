{"ast":null,"code":"// I need to rewrite this\n\nimport parse_var from './parse-var.js';\nimport parse_svg from './parse-svg.js';\nimport { generate_svg_extended } from '../generator/svg-extended.js';\nimport { first, last, clone } from '../utils/list.js';\nconst Tokens = {\n  func() {\n    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    return {\n      type: 'func',\n      name,\n      arguments: []\n    };\n  },\n  argument() {\n    return {\n      type: 'argument',\n      value: []\n    };\n  },\n  text() {\n    let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    return {\n      type: 'text',\n      value\n    };\n  },\n  pseudo() {\n    let selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    return {\n      type: 'pseudo',\n      selector,\n      styles: []\n    };\n  },\n  cond() {\n    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    return {\n      type: 'cond',\n      name,\n      styles: [],\n      arguments: []\n    };\n  },\n  rule() {\n    let property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    return {\n      type: 'rule',\n      property,\n      value: []\n    };\n  },\n  keyframes() {\n    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    return {\n      type: 'keyframes',\n      name,\n      steps: []\n    };\n  },\n  step() {\n    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    return {\n      type: 'step',\n      name,\n      styles: []\n    };\n  }\n};\nconst is = {\n  white_space(c) {\n    return /[\\s\\n\\t]/.test(c);\n  },\n  line_break(c) {\n    return /\\n/.test(c);\n  },\n  number(n) {\n    return !isNaN(n);\n  },\n  pair(n) {\n    return ['\"', '(', ')', \"'\"].includes(n);\n  },\n  pair_of(c, n) {\n    return {\n      '\"': '\"',\n      \"'\": \"'\",\n      '(': ')'\n    }[c] == n;\n  }\n};\n\n// This should not be in the parser\n// but I'll leave it here until the rewriting\nconst symbols = {\n  'π': Math.PI,\n  '∏': Math.PI\n};\nfunction composible(name) {\n  return /^@(canvas|shaders|doodle)/.test(name);\n}\nfunction iterator() {\n  let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  let index = 0,\n    col = 1,\n    line = 1;\n  return {\n    curr() {\n      let n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      return input[index + n];\n    },\n    end() {\n      return input.length <= index;\n    },\n    info() {\n      return {\n        index,\n        col,\n        line\n      };\n    },\n    index(n) {\n      return n === undefined ? index : index = n;\n    },\n    range(start, end) {\n      return input.substring(start, end);\n    },\n    next() {\n      let next = input[index++];\n      if (next == '\\n') line++, col = 0;else col++;\n      return next;\n    }\n  };\n}\nfunction throw_error(msg, _ref) {\n  let {\n    col,\n    line\n  } = _ref;\n  console.warn(`(at line ${line}, column ${col}) ${msg}`);\n}\nfunction get_text_value(input) {\n  if (input.trim().length) {\n    return is.number(+input) ? +input : input.trim();\n  } else {\n    return input;\n  }\n}\nfunction read_until(fn) {\n  return function (it, reset) {\n    let index = it.index();\n    let word = '';\n    while (!it.end()) {\n      let c = it.next();\n      if (fn(c)) break;else word += c;\n    }\n    if (reset) {\n      it.index(index);\n    }\n    return word;\n  };\n}\nfunction read_word(it, reset) {\n  let check = c => /[^\\w@]/.test(c);\n  return read_until(check)(it, reset);\n}\nfunction read_keyframe_name(it) {\n  return read_until(c => /[\\s\\{]/.test(c))(it);\n}\nfunction read_line(it, reset) {\n  let check = c => is.line_break(c) || c == '{';\n  return read_until(check)(it, reset);\n}\nfunction read_step(it, extra) {\n  let c,\n    step = Tokens.step();\n  while (!it.end()) {\n    if ((c = it.curr()) == '}') break;\n    if (is.white_space(c)) {\n      it.next();\n      continue;\n    } else if (!step.name.length) {\n      step.name = read_selector(it);\n    } else {\n      step.styles.push(read_rule(it, extra));\n      if (it.curr() == '}') break;\n    }\n    it.next();\n  }\n  return step;\n}\nfunction read_steps(it, extra) {\n  const steps = [];\n  let c;\n  while (!it.end()) {\n    if ((c = it.curr()) == '}') break;else if (is.white_space(c)) {\n      it.next();\n      continue;\n    } else {\n      steps.push(read_step(it, extra));\n    }\n    it.next();\n  }\n  return steps;\n}\nfunction read_keyframes(it, extra) {\n  let keyframes = Tokens.keyframes(),\n    c;\n  while (!it.end()) {\n    if ((c = it.curr()) == '}') break;else if (!keyframes.name.length) {\n      read_word(it);\n      keyframes.name = read_keyframe_name(it);\n      if (!keyframes.name.length) {\n        throw_error('missing keyframes name', it.info());\n        break;\n      }\n      continue;\n    } else if (c == '{' || it.curr(-1) == '{') {\n      it.next();\n      keyframes.steps = read_steps(it, extra);\n      break;\n    }\n    it.next();\n  }\n  return keyframes;\n}\nfunction read_comments(it) {\n  let flag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  it.next();\n  while (!it.end()) {\n    let c = it.curr();\n    if (flag.inline) {\n      if (c == '\\n') break;\n    } else {\n      if ((c = it.curr()) == '*' && it.curr(1) == '/') break;\n    }\n    it.next();\n  }\n  if (!flag.inline) {\n    it.next();\n    it.next();\n  }\n}\nfunction skip_tag(it) {\n  it.next();\n  while (!it.end()) {\n    let c = it.curr();\n    if (c == '>') break;\n    it.next();\n  }\n}\nfunction read_property(it) {\n  let prop = '',\n    c;\n  while (!it.end()) {\n    if ((c = it.curr()) == ':') break;else if (!is.white_space(c)) prop += c;\n    it.next();\n  }\n  return prop;\n}\nfunction read_arguments(it, composition, doodle) {\n  let variables = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  let args = [],\n    group = [],\n    stack = [],\n    arg = '',\n    c;\n  let raw = '';\n  while (!it.end()) {\n    c = it.curr();\n    let prev = it.curr(-1);\n    let start = it.index();\n    if (/[\\('\"`]/.test(c) && prev !== '\\\\') {\n      if (stack.length) {\n        /*\n        if ((c !== '(') && last(stack) === '(') {\n          stack.pop();\n        }\n        */\n        if (c !== '(' && c === last(stack)) {\n          stack.pop();\n        } else {\n          stack.push(c);\n        }\n      } else {\n        stack.push(c);\n      }\n      arg += c;\n    } else if (!doodle && (c == '@' || c === '$' || prev === '.' && composition)) {\n      if (!group.length) {\n        arg = arg.trimLeft();\n      }\n      if (arg.length) {\n        group.push(Tokens.text(arg));\n        arg = '';\n      }\n      group.push(read_func(it, variables));\n    } else if (doodle && /[)]/.test(c) || !doodle && /[,)]/.test(c)) {\n      if (stack.length) {\n        if (c == ')' && last(stack) === '(') {\n          stack.pop();\n        }\n        arg += c;\n      } else {\n        if (arg.length) {\n          if (!group.length) {\n            group.push(Tokens.text(get_text_value(arg)));\n          } else if (/\\S/.test(arg)) {\n            group.push(Tokens.text(arg));\n          }\n          if (arg.startsWith('±') && !doodle) {\n            let raw = arg.substr(1);\n            let cloned = clone(group);\n            last(cloned).value = '-' + raw;\n            args.push(normalize_argument(cloned));\n            last(group).value = raw;\n          }\n        }\n        args.push(normalize_argument(group));\n        [group, arg] = [[], ''];\n        if (c == ')') break;\n      }\n    } else {\n      if (symbols[c] && !/[0-9]/.test(it.curr(-1))) {\n        c = symbols[c];\n      }\n      arg += c;\n    }\n    if (composition && (it.curr(1) == ')' || it.curr(1) == ';' || !/[0-9a-zA-Z_\\-.]/.test(it.curr())) && !stack.length) {\n      if (group.length) {\n        args.push(normalize_argument(group));\n      }\n      break;\n    } else {\n      raw += it.range(start, it.index() + 1);\n      it.next();\n    }\n  }\n  return [skip_last_empty_args(args), raw];\n}\nfunction skip_last_empty_args(args) {\n  let arg = last(args[0]);\n  if (arg && arg.type === 'text' && !String(arg.value).trim().length) {\n    args[0] = args[0].slice(0, -1);\n  }\n  return args;\n}\nfunction normalize_argument(group) {\n  let result = group.map(arg => {\n    if (arg.type == 'text' && typeof arg.value == 'string') {\n      let value = String(arg.value);\n      if (value.includes('`')) {\n        arg.value = value = value.replace(/`/g, '\"');\n      }\n      arg.value = value;\n    }\n    return arg;\n  });\n  let ft = first(result) || {};\n  let ed = last(result) || {};\n  if (ft.type == 'text' && ed.type == 'text') {\n    let cf = first(ft.value);\n    let ce = last(ed.value);\n    if (typeof ft.value == 'string' && typeof ed.value == 'string') {\n      if (is.pair_of(cf, ce)) {\n        ft.value = ft.value.slice(1);\n        ed.value = ed.value.slice(0, ed.value.length - 1);\n        result.cluster = true;\n      }\n    }\n  }\n  return result;\n}\nfunction seperate_func_name(name) {\n  let fname = '',\n    extra = '';\n  if (/\\D$/.test(name) && !/\\d+[x-]\\d+/.test(name) || Math[name.substr(1)]) {\n    return {\n      fname: name,\n      extra\n    };\n  }\n  for (let i = name.length - 1; i >= 0; i--) {\n    let c = name[i];\n    let prev = name[i - 1];\n    let next = name[i + 1];\n    if (/[\\d.]/.test(c) || (c == 'x' || c == '-') && /\\d/.test(prev) && /\\d/.test(next)) {\n      extra = c + extra;\n    } else {\n      fname = name.substring(0, i + 1);\n      break;\n    }\n  }\n  return {\n    fname,\n    extra\n  };\n}\nfunction has_times_syntax(token) {\n  let str = JSON.stringify(token);\n  return str.includes('pureName') && str.includes('times');\n}\nfunction is_svg(name) {\n  return /^@svg$/i.test(name);\n}\nfunction read_func(it) {\n  let variables = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let func = Tokens.func();\n  let name = it.curr(),\n    c;\n  let has_argument = false;\n  let is_calc = name === '$';\n  ;\n  if (name === '@') {\n    it.next();\n  } else {\n    name = '@';\n  }\n  while (!it.end()) {\n    c = it.curr();\n    let next = it.curr(1);\n    let composition = c == '.' && /[a-zA-Z@$]/.test(next);\n    if (c == '(' || composition) {\n      has_argument = true;\n      it.next();\n      let [args, raw_args] = read_arguments(it, composition, composible(name), variables);\n      if (is_svg(name)) {\n        let parsed_svg = parse_svg(raw_args);\n        let line = 0;\n        for (let item of parsed_svg.value) {\n          if (item.variable) {\n            variables[item.name] = parse(`${'\\n'.repeat(line++)} ${item.name}: ${item.value}`)[0].value;\n          }\n        }\n        if (/\\d\\s*{/.test(raw_args) && has_times_syntax(parsed_svg)) {\n          let svg = generate_svg_extended(parsed_svg);\n          // compatible with old iterator\n          svg += ')';\n          let extended = read_arguments(iterator(svg), composition, composible(name), variables);\n          args = extended[0];\n        }\n      }\n      func.arguments = args;\n      func.variables = variables;\n      break;\n    } else if (/[0-9a-zA-Z_\\-.%]/.test(c)) {\n      name += c;\n    }\n    if (!has_argument && next !== '(' && !/[0-9a-zA-Z_\\-.%]/.test(next)) {\n      break;\n    }\n    it.next();\n  }\n  let {\n    fname,\n    extra\n  } = seperate_func_name(name);\n  func.name = is_calc ? '@$' + name.substr(1) : fname;\n  if (extra.length) {\n    func.arguments.unshift([{\n      type: 'text',\n      value: extra\n    }]);\n  }\n  if (is_calc && func.name.length > 2) {\n    if (!func.arguments.length) {\n      let name = func.name.substring(0, 2);\n      let value = func.name.substring(2);\n      func.name = name;\n      func.arguments.push([{\n        type: 'text',\n        value: value\n      }]);\n    }\n    if (/\\d$/.test(func.name)) {\n      let name = func.name.substring(0, 2);\n      let value = func.name.substring(2);\n      func.name = name;\n      func.arguments[0][0].value = value;\n    }\n  }\n  func.position = it.info().index;\n  return func;\n}\nfunction read_value(it) {\n  let text = Tokens.text(),\n    idx = 0,\n    skip = true,\n    c;\n  const value = [];\n  value[idx] = [];\n  let stack = [],\n    quote_stack = [];\n  while (!it.end()) {\n    c = it.curr();\n    if (skip && is.white_space(c)) {\n      it.next();\n      continue;\n    } else {\n      skip = false;\n    }\n    if (c == '\\n' && !is.white_space(it.curr(-1))) {\n      text.value += ' ';\n    } else if (c == ',' && !stack.length) {\n      if (text.value.length) {\n        value[idx].push(text);\n        text = Tokens.text();\n      }\n      value[++idx] = [];\n      skip = true;\n    } else if (/[;}<]/.test(c) && !quote_stack.length) {\n      if (text.value.length) {\n        value[idx].push(text);\n        text = Tokens.text();\n      }\n      break;\n    } else if ((c === '@' || c === '$') && /[\\w-\\(%]/.test(it.curr(1))) {\n      if (text.value.length) {\n        value[idx].push(text);\n        text = Tokens.text();\n      }\n      value[idx].push(read_func(it));\n    } else if (c === '\"' || c === \"'\") {\n      let quote = last(quote_stack);\n      if (c === quote) {\n        quote_stack.pop();\n      } else if (!quote_stack.length) {\n        quote_stack.push(c);\n      }\n      text.value += c;\n    } else if (!is.white_space(c) || !is.white_space(it.curr(-1))) {\n      if (c == '(') stack.push(c);\n      if (c == ')') stack.pop();\n      if (symbols[c] && !/[0-9]/.test(it.curr(-1))) {\n        c = symbols[c];\n      }\n      text.value += c;\n    }\n    if ((it.curr() === ';' || it.curr() == '}') && !quote_stack.length) {\n      break;\n    }\n    it.next();\n  }\n  if (text.value.length) {\n    value[idx].push(text);\n  }\n  return value;\n}\nfunction read_selector(it) {\n  let selector = '',\n    c;\n  while (!it.end()) {\n    if ((c = it.curr()) == '{') break;else {\n      selector += c;\n    }\n    it.next();\n  }\n  selector = selector.trim();\n  return selector;\n}\nfunction read_cond_selector(it) {\n  let selector = {\n      name: '',\n      arguments: []\n    },\n    c;\n  while (!it.end()) {\n    if ((c = it.curr()) == '(') {\n      it.next();\n      selector.arguments = read_arguments(it)[0];\n    } else if (/[){]/.test(c)) break;else selector.name += c;\n    it.next();\n  }\n  let [name, ...addition] = selector.name.trim().split(/\\s+/);\n  selector.name = name;\n  selector.addition = addition;\n  return selector;\n}\nfunction read_pseudo(it, extra) {\n  let pseudo = Tokens.pseudo(),\n    c;\n  while (!it.end()) {\n    c = it.curr();\n    if (c == '/' && it.curr(1) == '*') {\n      read_comments(it);\n    } else if (c == '}') {\n      break;\n    } else if (is.white_space(c)) {\n      it.next();\n      continue;\n    } else if (!pseudo.selector) {\n      pseudo.selector = read_selector(it);\n    } else {\n      let rule = read_rule(it, extra);\n      if (rule.property == '@use') {\n        pseudo.styles = pseudo.styles.concat(rule.value);\n      } else if (rule.property) {\n        pseudo.styles.push(rule);\n      }\n      if (it.curr() == '}') break;\n    }\n    it.next();\n  }\n  return pseudo;\n}\nfunction read_rule(it, extra) {\n  let rule = Tokens.rule(),\n    c;\n  let start = it.index();\n  while (!it.end()) {\n    c = it.curr();\n    if (c == '/' && it.curr(1) == '*') {\n      read_comments(it);\n    } else if (c == ';') {\n      break;\n    } else if (!rule.property.length) {\n      rule.property = read_property(it);\n      if (rule.property == '@use') {\n        rule.value = read_var(it, extra);\n        break;\n      }\n    } else {\n      rule.value = read_value(it);\n      break;\n    }\n    it.next();\n  }\n  let end = it.index();\n  rule.raw = () => it.range(start, end).trim();\n  return rule;\n}\nfunction read_cond(it, extra) {\n  let cond = Tokens.cond(),\n    c;\n  while (!it.end()) {\n    c = it.curr();\n    if (c == '/' && it.curr(1) == '*') {\n      read_comments(it);\n    } else if (c == '}') {\n      break;\n    } else if (!cond.name.length) {\n      Object.assign(cond, read_cond_selector(it));\n    } else if (c == ':') {\n      let pseudo = read_pseudo(it);\n      if (pseudo.selector) cond.styles.push(pseudo);\n    } else if (c == '@' && !read_line(it, true).includes(':')) {\n      cond.styles.push(read_cond(it));\n    } else if (!is.white_space(c)) {\n      let rule = read_rule(it, extra);\n      if (rule.property) cond.styles.push(rule);\n      if (it.curr() == '}') break;\n    }\n    it.next();\n  }\n  return cond;\n}\nfunction read_variable(extra, name) {\n  let rule = '';\n  if (extra && extra.get_variable) {\n    rule = extra.get_variable(name);\n  }\n  return rule;\n}\nfunction evaluate_value(values, extra) {\n  values.forEach && values.forEach(v => {\n    if (v.type == 'text' && v.value) {\n      let vars = parse_var(v.value);\n      v.value = vars.reduce((ret, p) => {\n        let rule = '',\n          other = '',\n          parsed;\n        rule = read_variable(extra, p.name);\n        if (!rule && p.fallback) {\n          p.fallback.every(n => {\n            other = read_variable(extra, n.name);\n            if (other) {\n              rule = other;\n              return false;\n            }\n          });\n        }\n        try {\n          parsed = parse(rule, extra);\n        } catch (e) {}\n        if (parsed) {\n          ret.push.apply(ret, parsed);\n        }\n        return ret;\n      }, []);\n    }\n    if (v.type == 'func' && v.arguments) {\n      v.arguments.forEach(arg => {\n        evaluate_value(arg, extra);\n      });\n    }\n  });\n}\nfunction read_var(it, extra) {\n  it.next();\n  let groups = read_value(it) || [];\n  return groups.reduce((ret, group) => {\n    evaluate_value(group, extra);\n    let [token] = group;\n    if (token.value && token.value.length) {\n      ret.push(...token.value);\n    }\n    return ret;\n  }, []);\n}\nexport default function parse(input, extra) {\n  const it = iterator(input);\n  const Tokens = [];\n  while (!it.end()) {\n    let c = it.curr();\n    if (is.white_space(c)) {\n      it.next();\n      continue;\n    } else if (c == '/' && it.curr(1) == '*') {\n      read_comments(it);\n    } else if (c == ':') {\n      let pseudo = read_pseudo(it, extra);\n      if (pseudo.selector) Tokens.push(pseudo);\n    } else if (c == '@' && read_word(it, true) === '@keyframes') {\n      let keyframes = read_keyframes(it, extra);\n      Tokens.push(keyframes);\n    } else if (c == '@' && !read_line(it, true).includes(':')) {\n      let cond = read_cond(it, extra);\n      if (cond.name.length) Tokens.push(cond);\n    } else if (c == '<') {\n      skip_tag(it);\n    } else if (!is.white_space(c)) {\n      let rule = read_rule(it, extra);\n      if (rule.property) Tokens.push(rule);\n    }\n    it.next();\n  }\n  return Tokens;\n}","map":{"version":3,"names":["parse_var","parse_svg","generate_svg_extended","first","last","clone","Tokens","func","name","type","arguments","argument","value","text","pseudo","selector","styles","cond","rule","property","keyframes","steps","step","is","white_space","c","test","line_break","number","n","isNaN","pair","includes","pair_of","symbols","Math","PI","composible","iterator","input","index","col","line","curr","end","length","info","undefined","range","start","substring","next","throw_error","msg","console","warn","get_text_value","trim","read_until","fn","it","reset","word","read_word","check","read_keyframe_name","read_line","read_step","extra","read_selector","push","read_rule","read_steps","read_keyframes","read_comments","flag","inline","skip_tag","read_property","prop","read_arguments","composition","doodle","variables","args","group","stack","arg","raw","prev","pop","trimLeft","read_func","startsWith","substr","cloned","normalize_argument","skip_last_empty_args","String","slice","result","map","replace","ft","ed","cf","ce","cluster","seperate_func_name","fname","i","has_times_syntax","token","str","JSON","stringify","is_svg","has_argument","is_calc","raw_args","parsed_svg","item","variable","parse","repeat","svg","extended","unshift","position","read_value","idx","skip","quote_stack","quote","read_cond_selector","addition","split","read_pseudo","concat","read_var","read_cond","Object","assign","read_variable","get_variable","evaluate_value","values","forEach","v","vars","reduce","ret","p","other","parsed","fallback","every","e","apply","groups"],"sources":["/Users/mariaeduardatc/Documents/GitHub/website/node_modules/css-doodle/src/parser/parse-css.js"],"sourcesContent":["// I need to rewrite this\n\nimport parse_var from './parse-var.js';\nimport parse_svg from './parse-svg.js';\nimport { generate_svg_extended } from '../generator/svg-extended.js';\nimport { first, last, clone } from '../utils/list.js';\n\nconst Tokens = {\n  func(name = '') {\n    return {\n      type: 'func',\n      name,\n      arguments: []\n    };\n  },\n  argument() {\n    return {\n      type: 'argument',\n      value: []\n    };\n  },\n  text(value = '') {\n    return {\n      type: 'text',\n      value\n    };\n  },\n  pseudo(selector = '') {\n    return {\n      type: 'pseudo',\n      selector,\n      styles: []\n    };\n  },\n  cond(name = '') {\n    return {\n      type: 'cond',\n      name,\n      styles: [],\n      arguments: []\n    };\n  },\n  rule(property = '') {\n    return {\n      type: 'rule',\n      property,\n      value: []\n    };\n  },\n  keyframes(name = '') {\n    return {\n      type: 'keyframes',\n      name,\n      steps: []\n    }\n  },\n\n  step(name = '') {\n    return {\n      type: 'step',\n      name,\n      styles: []\n    }\n  }\n};\n\nconst is = {\n  white_space(c) {\n    return /[\\s\\n\\t]/.test(c);\n  },\n  line_break(c) {\n    return /\\n/.test(c);\n  },\n  number(n) {\n    return !isNaN(n);\n  },\n  pair(n) {\n    return ['\"', '(', ')', \"'\"].includes(n);\n  },\n  pair_of(c, n) {\n    return ({ '\"': '\"', \"'\": \"'\", '(': ')' })[c] == n;\n  }\n};\n\n// This should not be in the parser\n// but I'll leave it here until the rewriting\nconst symbols = {\n  'π': Math.PI,\n  '∏': Math.PI\n};\n\nfunction composible(name) {\n  return /^@(canvas|shaders|doodle)/.test(name);\n}\n\nfunction iterator(input = '') {\n  let index = 0, col = 1, line = 1;\n  return {\n    curr(n = 0) {\n      return input[index + n];\n    },\n    end() {\n      return input.length <= index;\n    },\n    info() {\n      return { index, col, line };\n    },\n    index(n) {\n      return (n === undefined ? index : index = n);\n    },\n    range(start, end) {\n      return input.substring(start, end);\n    },\n    next() {\n      let next = input[index++];\n      if (next == '\\n') line++, col = 0;\n      else col++;\n      return next;\n    }\n  };\n}\n\nfunction throw_error(msg, { col, line }) {\n  console.warn(\n    `(at line ${ line }, column ${ col }) ${ msg }`\n  );\n}\n\nfunction get_text_value(input) {\n  if (input.trim().length) {\n    return is.number(+input) ? +input : input.trim()\n  } else {\n    return input;\n  }\n}\n\nfunction read_until(fn) {\n  return function(it, reset) {\n    let index = it.index();\n    let word = '';\n    while (!it.end()) {\n      let c = it.next();\n      if (fn(c)) break;\n      else word += c;\n    }\n    if (reset) {\n      it.index(index);\n    }\n    return word;\n  }\n}\n\nfunction read_word(it, reset) {\n  let check = c => /[^\\w@]/.test(c);\n  return read_until(check)(it, reset);\n}\n\nfunction read_keyframe_name(it) {\n  return read_until(c => /[\\s\\{]/.test(c))(it);\n}\n\nfunction read_line(it, reset) {\n  let check = c => is.line_break(c) || c == '{';\n  return read_until(check)(it, reset);\n}\n\nfunction read_step(it, extra) {\n  let c, step = Tokens.step();\n  while (!it.end()) {\n    if ((c = it.curr()) == '}') break;\n    if (is.white_space(c)) {\n      it.next();\n      continue;\n    }\n    else if (!step.name.length) {\n      step.name = read_selector(it);\n    }\n    else {\n      step.styles.push(read_rule(it, extra));\n      if (it.curr() == '}') break;\n    }\n    it.next();\n  }\n  return step;\n}\n\nfunction read_steps(it, extra) {\n  const steps = [];\n  let c;\n  while (!it.end()) {\n    if ((c = it.curr()) == '}') break;\n    else if (is.white_space(c)) {\n      it.next();\n      continue;\n    }\n    else {\n      steps.push(read_step(it, extra));\n    }\n    it.next();\n  }\n  return steps;\n}\n\nfunction read_keyframes(it, extra) {\n  let keyframes = Tokens.keyframes(), c;\n  while (!it.end()) {\n    if ((c = it.curr()) == '}') break;\n    else if (!keyframes.name.length) {\n      read_word(it);\n      keyframes.name = read_keyframe_name(it);\n      if (!keyframes.name.length) {\n        throw_error('missing keyframes name', it.info());\n        break;\n      }\n      continue;\n    }\n    else if (c == '{' || it.curr(-1) == '{') {\n      it.next();\n      keyframes.steps = read_steps(it, extra);\n      break;\n    }\n    it.next();\n  }\n  return keyframes;\n}\n\nfunction read_comments(it, flag = {}) {\n  it.next();\n  while (!it.end()) {\n    let c = it.curr();\n    if (flag.inline) {\n      if (c == '\\n') break;\n    }\n    else {\n      if ((c = it.curr()) == '*' && it.curr(1) == '/') break;\n    }\n    it.next();\n  }\n  if (!flag.inline) {\n    it.next(); it.next();\n  }\n}\n\nfunction skip_tag(it) {\n  it.next();\n  while(!it.end()) {\n    let c = it.curr();\n    if (c == '>') break;\n    it.next();\n  }\n}\n\nfunction read_property(it) {\n  let prop = '', c;\n  while (!it.end()) {\n    if ((c = it.curr()) == ':') break;\n    else if (!is.white_space(c)) prop += c;\n    it.next();\n  }\n  return prop;\n}\n\nfunction read_arguments(it, composition, doodle, variables = {}) {\n  let args = [], group = [], stack = [], arg = '', c;\n  let raw = '';\n  while (!it.end()) {\n    c = it.curr();\n    let prev = it.curr(-1);\n    let start = it.index();\n    if ((/[\\('\"`]/.test(c) && prev !== '\\\\')) {\n      if (stack.length) {\n        /*\n        if ((c !== '(') && last(stack) === '(') {\n          stack.pop();\n        }\n        */\n        if (c !== '(' && c === last(stack)) {\n          stack.pop();\n        } else {\n          stack.push(c);\n        }\n      } else {\n        stack.push(c);\n      }\n      arg += c;\n    }\n    else if (!doodle && ((c == '@' || c === '$') || (prev === '.' && composition))) {\n      if (!group.length) {\n        arg = arg.trimLeft();\n      }\n      if (arg.length) {\n        group.push(Tokens.text(arg));\n        arg = '';\n      }\n      group.push(read_func(it, variables));\n    }\n    else if (doodle && /[)]/.test(c) || (!doodle && /[,)]/.test(c))) {\n      if (stack.length) {\n        if (c == ')' && last(stack) === '(') {\n          stack.pop();\n        }\n        arg += c;\n      }\n      else {\n        if (arg.length) {\n          if (!group.length) {\n            group.push(Tokens.text(get_text_value(arg)));\n          } else if (/\\S/.test(arg)) {\n            group.push(Tokens.text(arg));\n          }\n          if (arg.startsWith('±') && !doodle) {\n            let raw = arg.substr(1);\n            let cloned = clone(group);\n            last(cloned).value = '-' + raw;\n            args.push(normalize_argument(cloned));\n            last(group).value = raw;\n          }\n        }\n\n        args.push(normalize_argument(group));\n\n        [group, arg] = [[], ''];\n\n        if (c == ')') break;\n      }\n    }\n    else {\n      if (symbols[c] && !/[0-9]/.test(it.curr(-1))) {\n        c = symbols[c];\n      }\n      arg += c;\n    }\n    if (composition && ((it.curr(1) == ')' || it.curr(1) == ';') || !/[0-9a-zA-Z_\\-.]/.test(it.curr())) && !stack.length) {\n      if (group.length) {\n        args.push(normalize_argument(group));\n      }\n      break;\n    }\n    else {\n      raw += it.range(start, it.index() + 1);\n      it.next();\n    }\n  }\n  return [skip_last_empty_args(args), raw];\n}\n\nfunction skip_last_empty_args(args) {\n  let arg = last(args[0]);\n  if (arg && arg.type === 'text' && !String(arg.value).trim().length) {\n    args[0] = args[0].slice(0, -1);\n  }\n  return args;\n}\n\nfunction normalize_argument(group) {\n  let result = group.map(arg => {\n    if (arg.type == 'text' && typeof arg.value == 'string') {\n      let value = String(arg.value);\n      if (value.includes('`')) {\n        arg.value = value = value.replace(/`/g, '\"');\n      }\n      arg.value = value;\n    }\n    return arg;\n  });\n\n  let ft = first(result) || {};\n  let ed = last(result) || {};\n  if (ft.type == 'text' && ed.type == 'text') {\n    let cf = first(ft.value);\n    let ce  = last(ed.value);\n    if (typeof ft.value == 'string' && typeof ed.value == 'string') {\n      if (is.pair_of(cf, ce)) {\n        ft.value = ft.value.slice(1);\n        ed.value = ed.value.slice(0, ed.value.length - 1);\n        result.cluster = true;\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction seperate_func_name(name) {\n  let fname = '', extra = '';\n  if ((/\\D$/.test(name) && !/\\d+[x-]\\d+/.test(name)) || Math[name.substr(1)]) {\n    return { fname: name, extra }\n  }\n  for (let i = name.length - 1; i >= 0; i--) {\n    let c = name[i];\n    let prev = name[i - 1];\n    let next = name[i + 1];\n    if (/[\\d.]/.test(c) || ((c == 'x' || c == '-') && /\\d/.test(prev) && /\\d/.test(next))) {\n      extra = c + extra;\n    } else {\n      fname = name.substring(0, i + 1);\n      break;\n    }\n  }\n  return { fname, extra };\n}\n\nfunction has_times_syntax(token) {\n  let str = JSON.stringify(token);\n  return str.includes('pureName') && str.includes('times');\n}\n\nfunction is_svg(name) {\n  return /^@svg$/i.test(name);\n}\n\nfunction read_func(it, variables = {}) {\n  let func = Tokens.func();\n  let name = it.curr(), c;\n  let has_argument = false;\n  let is_calc = name === '$';;\n  if (name === '@') {\n    it.next();\n  } else {\n    name = '@';\n  }\n  while (!it.end()) {\n    c = it.curr();\n    let next = it.curr(1);\n    let composition = (c == '.' && (/[a-zA-Z@$]/.test(next)));\n    if (c == '(' || composition) {\n      has_argument = true;\n      it.next();\n      let [args, raw_args] = read_arguments(it, composition, composible(name), variables);\n      if (is_svg(name)) {\n        let parsed_svg = parse_svg(raw_args);\n        let line = 0;\n        for (let item of parsed_svg.value) {\n          if (item.variable) {\n            variables[item.name] = (parse(`${'\\n'.repeat(line++)} ${item.name}: ${item.value}`))[0].value;\n          }\n        }\n        if (/\\d\\s*{/.test(raw_args) && has_times_syntax(parsed_svg)) {\n          let svg = generate_svg_extended(parsed_svg);\n          // compatible with old iterator\n          svg += ')';\n          let extended = read_arguments(iterator(svg), composition, composible(name), variables);\n          args = extended[0];\n        }\n      }\n      func.arguments = args;\n      func.variables = variables;\n      break;\n    } else if (/[0-9a-zA-Z_\\-.%]/.test(c)) {\n      name += c;\n    }\n    if (!has_argument && next !== '(' && !/[0-9a-zA-Z_\\-.%]/.test(next)) {\n      break;\n    }\n    it.next();\n  }\n  let { fname, extra } = seperate_func_name(name);\n  func.name = is_calc ? '@$' + name.substr(1) : fname;\n  if (extra.length) {\n    func.arguments.unshift([{\n      type: 'text',\n      value: extra\n    }]);\n  }\n\n  if (is_calc && func.name.length > 2) {\n    if (!func.arguments.length) {\n      let name = func.name.substring(0, 2);\n      let value = func.name.substring(2);\n      func.name = name;\n      func.arguments.push(\n        [{ type: 'text', value: value }]\n      );\n    }\n    if (/\\d$/.test(func.name)) {\n      let name = func.name.substring(0, 2);\n      let value = func.name.substring(2);\n      func.name = name;\n      func.arguments[0][0].value = value;\n    }\n  }\n\n  func.position = it.info().index;\n  return func;\n}\n\nfunction read_value(it) {\n  let text = Tokens.text(), idx = 0, skip = true, c;\n  const value = [];\n  value[idx] = [];\n  let stack = [], quote_stack = [];\n\n  while (!it.end()) {\n    c = it.curr();\n\n    if (skip && is.white_space(c)) {\n      it.next();\n      continue;\n    } else {\n      skip = false;\n    }\n\n    if (c == '\\n' && !is.white_space(it.curr(-1))) {\n      text.value += ' ';\n    }\n    else if (c == ',' && !stack.length) {\n      if (text.value.length) {\n        value[idx].push(text);\n        text = Tokens.text();\n      }\n      value[++idx] = [];\n      skip = true;\n    }\n    else if (/[;}<]/.test(c) && !quote_stack.length) {\n      if (text.value.length) {\n        value[idx].push(text);\n        text = Tokens.text();\n      }\n      break;\n    }\n    else if ((c === '@' || c === '$') && /[\\w-\\(%]/.test(it.curr(1))) {\n      if (text.value.length) {\n        value[idx].push(text);\n        text = Tokens.text();\n      }\n      value[idx].push(read_func(it));\n    }\n    else if (c === '\"' || c === \"'\") {\n      let quote = last(quote_stack);\n      if (c === quote) {\n        quote_stack.pop();\n      } else if (!quote_stack.length) {\n        quote_stack.push(c);\n      }\n      text.value += c;\n    }\n    else if (!is.white_space(c) || !is.white_space(it.curr(-1))) {\n      if (c == '(') stack.push(c);\n      if (c == ')') stack.pop();\n\n      if (symbols[c] && !/[0-9]/.test(it.curr(-1))) {\n        c = symbols[c];\n      }\n      text.value += c;\n    }\n    if ((it.curr() === ';' || it.curr() == '}') && !quote_stack.length) {\n      break;\n    }\n    it.next();\n  }\n  if (text.value.length) {\n    value[idx].push(text);\n  }\n  return value;\n}\n\nfunction read_selector(it) {\n  let selector = '', c;\n  while (!it.end()) {\n    if ((c = it.curr()) == '{') break;\n    else {\n      selector += c;\n    }\n    it.next();\n  }\n  selector = selector.trim();\n  return selector;\n}\n\nfunction read_cond_selector(it) {\n  let selector = { name: '', arguments: [] }, c;\n  while (!it.end()) {\n    if ((c = it.curr()) == '(') {\n      it.next();\n      selector.arguments = read_arguments(it)[0];\n    }\n    else if (/[){]/.test(c)) break;\n    else selector.name += c;\n    it.next();\n  }\n  let [name, ...addition] = selector.name.trim().split(/\\s+/);\n  selector.name = name;\n  selector.addition = addition;\n  return selector;\n}\n\nfunction read_pseudo(it, extra) {\n  let pseudo = Tokens.pseudo(), c;\n  while (!it.end()) {\n    c = it.curr();\n    if (c == '/' && it.curr(1) == '*') {\n      read_comments(it);\n    }\n    else if (c == '}') {\n      break;\n    }\n    else if (is.white_space(c)) {\n      it.next();\n      continue;\n    }\n    else if (!pseudo.selector) {\n      pseudo.selector = read_selector(it);\n    }\n    else {\n      let rule = read_rule(it, extra);\n      if (rule.property == '@use') {\n        pseudo.styles = pseudo.styles.concat(\n          rule.value\n        );\n      } else if (rule.property) {\n        pseudo.styles.push(rule);\n      }\n      if (it.curr() == '}') break;\n    }\n    it.next();\n  }\n  return pseudo;\n}\n\nfunction read_rule(it, extra) {\n  let rule = Tokens.rule(), c;\n  let start = it.index();\n  while (!it.end()) {\n    c = it.curr();\n    if (c == '/' && it.curr(1) == '*') {\n      read_comments(it);\n    }\n    else if (c == ';') {\n      break;\n    }\n    else if (!rule.property.length) {\n      rule.property = read_property(it);\n      if (rule.property == '@use') {\n        rule.value = read_var(it, extra);\n        break;\n      }\n    }\n    else {\n      rule.value = read_value(it);\n      break;\n    }\n    it.next();\n  }\n  let end = it.index();\n  rule.raw = () => it.range(start, end).trim();\n  return rule;\n}\n\nfunction read_cond(it, extra) {\n  let cond = Tokens.cond(), c;\n  while (!it.end()) {\n    c = it.curr();\n    if (c == '/' && it.curr(1) == '*') {\n      read_comments(it);\n    }\n    else if (c == '}') {\n      break;\n    }\n    else if (!cond.name.length) {\n      Object.assign(cond, read_cond_selector(it));\n    }\n    else if (c == ':') {\n      let pseudo = read_pseudo(it);\n      if (pseudo.selector) cond.styles.push(pseudo);\n    }\n    else if (c == '@' && !read_line(it, true).includes(':')) {\n      cond.styles.push(read_cond(it));\n    }\n    else if (!is.white_space(c)) {\n      let rule = read_rule(it, extra);\n      if (rule.property) cond.styles.push(rule);\n      if (it.curr() == '}') break;\n    }\n    it.next();\n  }\n  return cond;\n}\n\nfunction read_variable(extra, name) {\n  let rule = '';\n  if (extra && extra.get_variable) {\n    rule = extra.get_variable(name);\n  }\n  return rule;\n}\n\nfunction evaluate_value(values, extra) {\n  values.forEach && values.forEach(v => {\n    if (v.type == 'text' && v.value) {\n      let vars = parse_var(v.value);\n      v.value = vars.reduce((ret, p) => {\n        let rule = '', other = '', parsed;\n        rule = read_variable(extra, p.name);\n        if (!rule && p.fallback) {\n          p.fallback.every(n => {\n            other = read_variable(extra, n.name);\n            if (other) {\n              rule = other;\n              return false;\n            }\n          });\n        }\n        try {\n          parsed = parse(rule, extra);\n        } catch (e) { }\n        if (parsed) {\n          ret.push.apply(ret, parsed);\n        }\n        return ret;\n      }, []);\n    }\n    if (v.type == 'func' && v.arguments) {\n      v.arguments.forEach(arg => {\n        evaluate_value(arg, extra);\n      });\n    }\n  });\n}\n\nfunction read_var(it, extra) {\n  it.next();\n  let groups = read_value(it) || [];\n  return groups.reduce((ret, group) => {\n    evaluate_value(group, extra);\n    let [token] = group;\n    if (token.value && token.value.length) {\n      ret.push(...token.value);\n    }\n    return ret;\n  }, []);\n}\n\nexport default function parse(input, extra) {\n  const it = iterator(input);\n  const Tokens = [];\n  while (!it.end()) {\n    let c = it.curr();\n    if (is.white_space(c)) {\n      it.next();\n      continue;\n    }\n    else if (c == '/' && it.curr(1) == '*') {\n      read_comments(it);\n    }\n    else if (c == ':') {\n      let pseudo = read_pseudo(it, extra);\n      if (pseudo.selector) Tokens.push(pseudo);\n    }\n    else if (c == '@' && read_word(it, true) === '@keyframes') {\n      let keyframes = read_keyframes(it, extra);\n      Tokens.push(keyframes);\n    }\n    else if (c == '@' && !read_line(it, true).includes(':')) {\n      let cond = read_cond(it, extra);\n      if (cond.name.length) Tokens.push(cond);\n    }\n    else if (c == '<') {\n      skip_tag(it);\n    }\n    else if (!is.white_space(c)) {\n      let rule = read_rule(it, extra);\n      if (rule.property) Tokens.push(rule);\n    }\n    it.next();\n  }\n  return Tokens;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}