{"ast":null,"code":"import { scan, iterator, Token } from './tokenizer.js';\nimport { is_empty } from '../utils/index.js';\nfunction parse(input) {\n  let scanOptions = {\n    preserveLineBreak: true,\n    ignoreInlineComment: true\n  };\n  let iter = iterator(removeParens(scan(input, scanOptions)));\n  let stack = [];\n  let tokens = [];\n  let identifier;\n  let line;\n  let result = {\n    textures: []\n  };\n  while (iter.next()) {\n    let {\n      curr,\n      next\n    } = iter.get();\n    if (curr.isSymbol('{')) {\n      if (!stack.length) {\n        let name = joinToken(tokens);\n        if (isIdentifier(name)) {\n          identifier = name;\n          tokens = [];\n        } else {\n          tokens.push(curr);\n        }\n      } else {\n        tokens.push(curr);\n      }\n      stack.push('{');\n    } else if (curr.isSymbol('}')) {\n      stack.pop();\n      if (!stack.length && identifier) {\n        let value = joinToken(tokens);\n        if (identifier && value.length) {\n          if (identifier.startsWith('texture')) {\n            result.textures.push({\n              name: identifier,\n              value\n            });\n          } else {\n            result[identifier] = value;\n          }\n          tokens = [];\n        }\n        identifier = null;\n      } else {\n        tokens.push(curr);\n      }\n    } else {\n      if (!is_empty(line) && line != curr.pos[1]) {\n        tokens.push(lineBreak());\n        line = null;\n      }\n      if (!identifier || !identifier.startsWith('texture')) {\n        if (curr.isWord() && curr.value.startsWith('#')) {\n          tokens.push(lineBreak());\n          line = next.pos[1];\n        }\n      }\n      tokens.push(curr);\n    }\n  }\n  if (is_empty(result.fragment)) {\n    result.fragment = joinToken(tokens);\n    result.textures = result.textures || [];\n  }\n  return result;\n}\nfunction isIdentifier(name) {\n  return /^texture\\w*$|^(fragment|vertex)$/.test(name);\n}\nfunction lineBreak() {\n  return new Token({\n    type: 'LineBreak',\n    value: '\\n'\n  });\n}\nfunction removeParens(tokens) {\n  let head = tokens[0];\n  let last = tokens[tokens.length - 1];\n  while (head && head.isSymbol('(') && last && last.isSymbol(')')) {\n    tokens = tokens.slice(1, tokens.length - 1);\n    head = tokens[0];\n    last = tokens[tokens.length - 1];\n  }\n  return tokens;\n}\nfunction joinToken(tokens) {\n  return removeParens(tokens).map(n => n.value).join('');\n}\nexport default parse;","map":{"version":3,"names":["scan","iterator","Token","is_empty","parse","input","scanOptions","preserveLineBreak","ignoreInlineComment","iter","removeParens","stack","tokens","identifier","line","result","textures","next","curr","get","isSymbol","length","name","joinToken","isIdentifier","push","pop","value","startsWith","pos","lineBreak","isWord","fragment","test","type","head","last","slice","map","n","join"],"sources":["/Users/mariaeduardatc/Documents/GitHub/website/node_modules/css-doodle/src/parser/parse-shaders.js"],"sourcesContent":["import { scan, iterator, Token } from './tokenizer.js';\nimport { is_empty } from '../utils/index.js';\n\nfunction parse(input) {\n  let scanOptions = {\n    preserveLineBreak: true,\n    ignoreInlineComment: true,\n  };\n  let iter = iterator(removeParens(scan(input, scanOptions)));\n  let stack = [];\n  let tokens = [];\n  let identifier;\n  let line;\n  let result = {\n    textures: [],\n  };\n  while (iter.next()) {\n    let { curr, next } = iter.get();\n    if (curr.isSymbol('{')) {\n      if (!stack.length) {\n        let name = joinToken(tokens);\n        if (isIdentifier(name)) {\n          identifier = name;\n          tokens = [];\n        } else {\n          tokens.push(curr);\n        }\n      } else {\n        tokens.push(curr);\n      }\n      stack.push('{');\n    }\n    else if (curr.isSymbol('}')) {\n      stack.pop();\n      if (!stack.length && identifier) {\n        let value = joinToken(tokens);\n        if (identifier && value.length) {\n          if (identifier.startsWith('texture')) {\n            result.textures.push({\n              name: identifier,\n              value\n            });\n          } else {\n            result[identifier] = value;\n          }\n          tokens = [];\n        }\n        identifier = null;\n      } else {\n        tokens.push(curr);\n      }\n    }\n    else {\n      if (!is_empty(line) && line != curr.pos[1]) {\n        tokens.push(lineBreak());\n        line = null;\n      }\n      if (!identifier || !identifier.startsWith('texture')) {\n        if (curr.isWord() && curr.value.startsWith('#')) {\n          tokens.push(lineBreak());\n          line = next.pos[1];\n        }\n      }\n      tokens.push(curr);\n    }\n  }\n\n  if (is_empty(result.fragment)) {\n    result.fragment = joinToken(tokens);\n    result.textures = result.textures || [];\n  }\n  return result;\n}\n\nfunction isIdentifier(name) {\n  return /^texture\\w*$|^(fragment|vertex)$/.test(name);\n}\n\nfunction lineBreak() {\n  return new Token({ type: 'LineBreak', value: '\\n' });\n}\n\nfunction removeParens(tokens) {\n  let head = tokens[0];\n  let last = tokens[tokens.length - 1];\n  while (head && head.isSymbol('(') && last && last.isSymbol(')')) {\n    tokens = tokens.slice(1, tokens.length - 1);\n    head = tokens[0];\n    last = tokens[tokens.length - 1];\n  }\n  return tokens;\n}\n\nfunction joinToken(tokens) {\n  return removeParens(tokens).map(n => n.value).join('');\n}\n\nexport default parse;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}